<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#222">
  <meta name="msapplication-config" content="/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hunkier.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 新特性">
<meta property="og:url" content="https://hunkier.cn/Java-New-Features/index.html">
<meta property="og:site_name" content="hunkier">
<meta property="og:description" content="队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/new-features/640.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png">
<meta property="og:image" content="https://oss.javaguide.cn/javaguide/image-20210820153955587.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/image-20210816154125579.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/image-20210816083417616.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/module-structure.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/image-20210816104614414.png">
<meta property="article:published_time" content="2023-12-31T10:55:09.000Z">
<meta property="article:modified_time" content="2023-12-31T12:19:02.080Z">
<meta property="article:author" content="hunkier">
<meta property="article:tag" content="java">
<meta property="article:tag" content="jdk">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oss.javaguide.cn/github/javaguide/java/new-features/640.png">

<link rel="canonical" href="https://hunkier.cn/Java-New-Features/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 新特性 | hunkier</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66022267-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-66022267-2');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9a6791fa58c4e04f3a197ec3ce831c0d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="hunkier" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hunkier</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记，开源代码，技术分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/My-wechat/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">92</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">100</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">64</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/hunkier" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hunkier.cn/Java-New-Features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/avatar.jpg">
      <meta itemprop="name" content="hunkier">
      <meta itemprop="description" content="学习笔记，开源代码，技术分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hunkier">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 新特性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-31 18:55:09 / 修改时间：20:19:02" itemprop="dateCreated datePublished" datetime="2023-12-31T18:55:09+08:00">2023-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jdk/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/Java-New-Features/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Java-New-Features/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。<br> <span id="more"></span> </p>
<h1 id="Java21-新特性"><a href="#Java21-新特性" class="headerlink" title="Java21 新特性"></a>Java21 新特性</h1><p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。</p>
<p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。</p>
<p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：</p>
<ul>
<li><p><a href="https://openjdk.org/jeps/430">JEP 430：String Templates（字符串模板）</a>（预览）</p>
</li>
<li><p><a href="https://openjdk.org/jeps/431">JEP 431：Sequenced Collections（序列化集合）</a></p>
</li>
<li><p><a href="https://openjdk.org/jeps/439">JEP 439：Generational ZGC（分代 ZGC）</a></p>
</li>
<li><p><a href="https://openjdk.org/jeps/440">JEP 440：Record Patterns（记录模式）</a></p>
</li>
<li><p><a href="https://openjdk.org/jeps/442">JEP 441：Pattern Matching for switch（switch 的模式匹配）</a></p>
</li>
<li><p><a href="https://openjdk.org/jeps/442">JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第三次预览）</p>
</li>
<li><p><a href="https://openjdk.org/jeps/443">JEP 443：Unnamed Patterns and Variables（未命名模式和变量</a>（预览）</p>
</li>
<li><p><a href="https://openjdk.org/jeps/444">JEP 444：Virtual Threads（虚拟线程）</a></p>
</li>
<li><p><a href="https://openjdk.org/jeps/445">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）</a>（预览）</p>
</li>
</ul>
<h2 id="JEP-430：字符串模板（预览）"><a href="#JEP-430：字符串模板（预览）" class="headerlink" title="JEP 430：字符串模板（预览）"></a>JEP 430：字符串模板（预览）</h2><p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。</p>
<p>String Templates 提供了一种更简洁、更直观的方式来动态构建字符串。通过使用占位符<code>$&#123;&#125;</code>，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。在运行时，Java 编译器会将这些占位符替换为实际的变量值。并且，表达式支持局部变量、静态/非静态字段甚至方法、计算结果等特性。</p>
<p>实际上，String Templates（字符串模板）再大多数编程语言中都存在:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Greetings &#123;&#123; name &#125;&#125;!&quot;</span>;  <span class="comment">//Angular</span></span><br><span class="line"><span class="string">`Greetings <span class="subst">$&#123; name &#125;</span>!`</span>;    <span class="comment">//Typescript</span></span><br><span class="line">$<span class="string">&quot;Greetings &#123; name &#125;!&quot;</span>    <span class="comment">//Visual basic</span></span><br><span class="line">f<span class="string">&quot;Greetings &#123; name &#125;!&quot;</span>    <span class="comment">//Python</span></span><br></pre></td></tr></table></figure>

<p>Java 在没有 String Templates 之前，我们通常使用字符串拼接或格式化方法来构建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concatenation</span></span><br><span class="line">message = <span class="string">&quot;Greetings &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String.format()</span></span><br><span class="line">message = String.format(<span class="string">&quot;Greetings %s!&quot;</span>, name);  <span class="comment">//concatenation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MessageFormat</span></span><br><span class="line">message = <span class="keyword">new</span> MessageFormat(<span class="string">&quot;Greetings &#123;0&#125;!&quot;</span>).format(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line">message = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;Greetings &quot;</span>).append(name).append(<span class="string">&quot;!&quot;</span>).toString();</span><br></pre></td></tr></table></figure>

<p>这些方法或多或少都存在一些缺点，比如难以阅读、冗长、复杂。</p>
<p>Java 使用 String Templates 进行字符串拼接，可以直接在字符串中嵌入表达式，而无需进行额外的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = STR.<span class="string">&quot;Greetings \&#123;name&#125;!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的模板表达式中：</p>
<ul>
<li>STR 是模板处理器。</li>
<li><code>\&#123;name&#125;</code>为表达式，运行时，这些表达式将被相应的变量值替换。</li>
</ul>
<p>Java 目前支持三种模板处理器：</p>
<ul>
<li>STR：自动执行字符串插值，即将模板中的每个嵌入式表达式替换为其值（转换为字符串）。</li>
<li>FMT：和 STR 类似，但是它还可以接受格式说明符，这些格式说明符出现在嵌入式表达式的左边，用来控制输出的样式</li>
<li>RAW：不会像 STR 和 FMT 模板处理器那样自动处理字符串模板，而是返回一个 <code>StringTemplate</code> 对象，这个对象包含了模板中的文本和表达式的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Lokesh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STR</span></span><br><span class="line">String message = STR.<span class="string">&quot;Greetings \&#123;name&#125;.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FMT</span></span><br><span class="line">String message = STR.<span class="string">&quot;Greetings %-12s\&#123;name&#125;.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RAW</span></span><br><span class="line">StringTemplate st = RAW.<span class="string">&quot;Greetings \&#123;name&#125;.&quot;</span>;</span><br><span class="line">String message = STR.process(st);</span><br></pre></td></tr></table></figure>

<p>除了 JDK 自带的三种模板处理器外，你还可以实现 <code>StringTemplate.Processor</code> 接口来创建自己的模板处理器。</p>
<p>我们可以使用局部变量、静态/非静态字段甚至方法作为嵌入表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//variable</span></span><br><span class="line">message = STR.<span class="string">&quot;Greetings \&#123;name&#125;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//method</span></span><br><span class="line">message = STR.<span class="string">&quot;Greetings \&#123;getName()&#125;!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//field</span></span><br><span class="line">message = STR.<span class="string">&quot;Greetings \&#123;this.name&#125;!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>还可以在表达式中执行计算并打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">String s = STR.<span class="string">&quot;\&#123;x&#125; + \&#123;y&#125; = \&#123;x + y&#125;&quot;</span>;  <span class="comment">//&quot;10 + 20 = 30&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了提高可读性，我们可以将嵌入的表达式分成多行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String time = STR.<span class="string">&quot;The current time is \&#123;</span></span><br><span class="line"><span class="string">    //sample comment - current time in HH:mm:ss</span></span><br><span class="line"><span class="string">    DateTimeFormatter</span></span><br><span class="line"><span class="string">      .ofPattern(&quot;</span>HH:mm:ss<span class="string">&quot;)</span></span><br><span class="line"><span class="string">      .format(LocalTime.now())</span></span><br><span class="line"><span class="string">  &#125;.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="JEP431：序列化集合"><a href="#JEP431：序列化集合" class="headerlink" title="JEP431：序列化集合"></a>JEP431：序列化集合</h2><p>JDK 21 引入了一种新的集合类型：<strong>Sequenced Collections（序列化集合，也叫有序集合）</strong>，这是一种具有确定出现顺序（encounter order）的集合（无论我们遍历这样的集合多少次，元素的出现顺序始终是固定的）。序列化集合提供了处理集合的第一个和最后一个元素以及反向视图（与原始集合相反的顺序）的简单方法。</p>
<p>Sequenced Collections 包括以下三个接口：</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html"><code>SequencedCollection</code></a></li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html"><code>SequencedSet</code></a></li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html"><code>SequencedMap</code></a></li>
</ul>
<p><code>SequencedCollection</code> 接口继承了 <code>Collection</code>接口， 提供了在集合两端访问、添加或删除元素以及获取集合的反向视图的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SequencedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// New Method</span></span><br><span class="line"></span><br><span class="line">  <span class="function">SequencedCollection&lt;E&gt; <span class="title">reversed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promoted methods from Deque&lt;E&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>List</code> 和 <code>Deque</code> 接口实现了<code>SequencedCollection</code> 接口。</p>
<p>这里以 <code>ArrayList</code> 为例，演示一下实际使用效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="number">1</span>);   <span class="comment">// List contains: [1]</span></span><br><span class="line"></span><br><span class="line">arrayList.addFirst(<span class="number">0</span>);  <span class="comment">// List contains: [0, 1]</span></span><br><span class="line">arrayList.addLast(<span class="number">2</span>);   <span class="comment">// List contains: [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line">Integer firstElement = arrayList.getFirst();  <span class="comment">// 0</span></span><br><span class="line">Integer lastElement = arrayList.getLast();  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; reversed = arrayList.reversed();</span><br><span class="line">System.out.println(reversed); <span class="comment">// Prints [2, 1, 0]</span></span><br></pre></td></tr></table></figure>

<p><code>SequencedSet</code>接口直接继承了 <code>SequencedCollection</code> 接口并重写了 <code>reversed()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SequencedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SequencedCollection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">SequencedSet&lt;E&gt; <span class="title">reversed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SortedSet</code> 和 <code>LinkedHashSet</code> 实现了<code>SequencedSet</code>接口。</p>
<p>这里以 <code>LinkedHashSet</code> 为例，演示一下实际使用效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Integer firstElement = linkedHashSet.getFirst();   <span class="comment">// 1</span></span><br><span class="line">Integer lastElement = linkedHashSet.getLast();    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">linkedHashSet.addFirst(<span class="number">0</span>);  <span class="comment">//List contains: [0, 1, 2, 3]</span></span><br><span class="line">linkedHashSet.addLast(<span class="number">4</span>);   <span class="comment">//List contains: [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">System.out.println(linkedHashSet.reversed());   <span class="comment">//Prints [5, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>

<p><code>SequencedMap</code> 接口继承了 <code>Map</code>接口， 提供了在集合两端访问、添加或删除键值对、获取包含 key 的 <code>SequencedSet</code>、包含 value 的 <code>SequencedCollection</code>、包含 entry（键值对） 的 <code>SequencedSet</code>以及获取集合的反向视图的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SequencedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// New Methods</span></span><br><span class="line"></span><br><span class="line">  <span class="function">SequencedMap&lt;K,V&gt; <span class="title">reversed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SequencedSet&lt;K&gt; <span class="title">sequencedKeySet</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">SequencedCollection&lt;V&gt; <span class="title">sequencedValues</span><span class="params">()</span></span>;</span><br><span class="line">  SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet();</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">putFirst</span><span class="params">(K, V)</span></span>;</span><br><span class="line">  <span class="function">V <span class="title">putLast</span><span class="params">(K, V)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promoted Methods from NavigableMap&lt;K, V&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Entry&lt;K, V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Entry&lt;K, V&gt; <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Entry&lt;K, V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Entry&lt;K, V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SortedMap</code> 和<code>LinkedHashMap</code> 实现了<code>SequencedMap</code> 接口。</p>
<p>这里以 <code>LinkedHashMap</code> 为例，演示一下实际使用效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;One&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;Two&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line"></span><br><span class="line">map.firstEntry();   <span class="comment">//1=One</span></span><br><span class="line">map.lastEntry();    <span class="comment">//3=Three</span></span><br><span class="line"></span><br><span class="line">System.out.println(map);  <span class="comment">//&#123;1=One, 2=Two, 3=Three&#125;</span></span><br><span class="line"></span><br><span class="line">Map.Entry&lt;Integer, String&gt; first = map.pollFirstEntry();   <span class="comment">//1=One</span></span><br><span class="line">Map.Entry&lt;Integer, String&gt; last = map.pollLastEntry();    <span class="comment">//3=Three</span></span><br><span class="line"></span><br><span class="line">System.out.println(map);  <span class="comment">//&#123;2=Two&#125;</span></span><br><span class="line"></span><br><span class="line">map.putFirst(<span class="number">1</span>, <span class="string">&quot;One&quot;</span>);     <span class="comment">//&#123;1=One, 2=Two&#125;</span></span><br><span class="line">map.putLast(<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>);    <span class="comment">//&#123;1=One, 2=Two, 3=Three&#125;</span></span><br><span class="line"></span><br><span class="line">System.out.println(map);  <span class="comment">//&#123;1=One, 2=Two, 3=Three&#125;</span></span><br><span class="line">System.out.println(map.reversed());   <span class="comment">//&#123;3=Three, 2=Two, 1=One&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="JEP-439：分代-ZGC"><a href="#JEP-439：分代-ZGC" class="headerlink" title="JEP 439：分代 ZGC"></a>JEP 439：分代 ZGC</h2><p>JDK21 中对 ZGC 进行了功能扩展，增加了分代 GC 功能。不过，默认是关闭的，需要通过配置打开：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启用分代ZGC</span><br><span class="line">java -XX:+UseZGC -XX:+ZGenerational ...</span><br></pre></td></tr></table></figure>

<p>在未来的版本中，官方会把 ZGenerational 设为默认值，即默认打开 ZGC 的分代 GC。在更晚的版本中，非分代 ZGC 就被移除。</p>
<blockquote>
<p>In a future release we intend to make Generational ZGC the default, at which point -XX:-ZGenerational will select non-generational ZGC. In an even later release we intend to remove non-generational ZGC, at which point the ZGenerational option will become obsolete.</p>
<p>在将来的版本中，我们打算将 Generational ZGC 作为默认选项，此时-XX:-ZGenerational 将选择非分代 ZGC。在更晚的版本中，我们打算移除非分代 ZGC，此时 ZGenerational 选项将变得过时。</p>
</blockquote>
<p>分代 ZGC 可以显著减少垃圾回收过程中的停顿时间，并提高应用程序的响应性能。这对于大型 Java 应用程序和高并发场景下的性能优化非常有价值。</p>
<h2 id="JEP-440：记录模式"><a href="#JEP-440：记录模式" class="headerlink" title="JEP 440：记录模式"></a>JEP 440：记录模式</h2><p>记录模式在 Java 19 进行了第一次预览， 由 <a href="https://openjdk.org/jeps/405">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/432">JEP 432</a> 提出。最终，记录模式在 JDK21 顺利转正。</p>
<p><a href="./java20.md">Java 20 新特性概览</a>已经详细介绍过记录模式，这里就不重复了。</p>
<h2 id="JEP-441：switch-的模式匹配"><a href="#JEP-441：switch-的模式匹配" class="headerlink" title="JEP 441：switch 的模式匹配"></a>JEP 441：switch 的模式匹配</h2><p>增强 Java 中的 switch 表达式和语句，允许在 case 标签中使用模式。当模式匹配时，执行 case 标签对应的代码。</p>
<p>在下面的代码中，switch 表达式使用了类型模式来进行匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatterPatternSwitch</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; obj.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JEP-442-外部函数和内存-API（第三次预览）"><a href="#JEP-442-外部函数和内存-API（第三次预览）" class="headerlink" title="JEP 442: 外部函数和内存 API（第三次预览）"></a>JEP 442: 外部函数和内存 API（第三次预览）</h2><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/434">JEP 434</a> 提出。JDK 21 中是第三次预览，由 <a href="https://openjdk.org/jeps/442">JEP 442</a> 提出。</p>
<p>在 <a href="./java19.md">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>
<h2 id="JEP-443：未命名模式和变量（预览）"><a href="#JEP-443：未命名模式和变量（预览）" class="headerlink" title="JEP 443：未命名模式和变量（预览）"></a>JEP 443：未命名模式和变量（预览）</h2><p>未命名模式和变量使得我们可以使用下划线 <code>_</code> 表示未命名的变量以及模式匹配时不使用的组件，旨在提高代码的可读性和可维护性。</p>
<p>未命名变量的典型场景是 <code>try-with-resources</code> 语句、 <code>catch</code> 子句中的异常变量和<code>for</code>循环。当变量不需要使用的时候就可以使用下划线 <code>_</code>代替，这样清晰标识未被使用的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> _ = ScopedContext.acquire()) &#123;</span><br><span class="line">  <span class="comment">// No use of acquired resource</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception _) &#123; ... &#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable _) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, _ = runOnce(); i &lt; arr.length; i++) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未命名模式是一个无条件的模式，并不绑定任何值。未命名模式变量出现在类型模式中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="function">r <span class="keyword">instanceof</span> <span class="title">ColoredPoint</span><span class="params">(_, Color c)</span>) </span>&#123; ... c ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (b) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">Box</span><span class="params">(RedBall _)</span>, <span class="title">Box</span><span class="params">(BlueBall _)</span> -&gt; <span class="title">processBox</span><span class="params">(b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">Box</span><span class="params">(GreenBall _)</span>                -&gt; <span class="title">stopProcessing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">Box</span><span class="params">(_)</span>                          -&gt; <span class="title">pickAnotherBox</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JEP-444：虚拟线程"><a href="#JEP-444：虚拟线程" class="headerlink" title="JEP 444：虚拟线程"></a>JEP 444：虚拟线程</h2><p>虚拟线程是一项重量级的更新，一定一定要重视！</p>
<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href="https://openjdk.org/jeps/425">JEP 425</a>提出。JDK 20 中是第二次预览。最终，虚拟线程在 JDK21 顺利转正。</p>
<p><a href="./java20.md">Java 20 新特性概览</a>已经详细介绍过虚拟线程，这里就不重复了。</p>
<h2 id="JEP-445：未命名类和实例-main-方法-（预览）"><a href="#JEP-445：未命名类和实例-main-方法-（预览）" class="headerlink" title="JEP 445：未命名类和实例 main 方法 （预览）"></a>JEP 445：未命名类和实例 main 方法 （预览）</h2><p>这个特性主要简化了 <code>main</code> 方法的的声明。对于 Java 初学者来说，这个 <code>main</code> 方法的声明引入了太多的 Java 语法概念，不利于初学者快速上手。</p>
<p>没有使用该特性之前定义一个 <code>main</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该新特性之后定义一个 <code>main</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步精简(未命名的类允许我们不定义类名)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Java 21 String Templates：<a href="https://howtodoinjava.com/java/java-string-templates/">https://howtodoinjava.com/java/java-string-templates/</a></li>
<li>Java 21 Sequenced Collections：<a href="https://howtodoinjava.com/java/sequenced-collections/">https://howtodoinjava.com/java/sequenced-collections/</a></li>
</ul>
<h1 id="Java20-新特性"><a href="#Java20-新特性" class="headerlink" title="Java20 新特性"></a>Java20 新特性</h1><p>JDK 20 于 2023 年 3 月 21 日发布，非长期支持版本。</p>
<p>根据开发计划，下一个 LTS 版本就是将于 2023 年 9 月发布的 JDK 21。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/640.png"></p>
<p>JDK 20 只有 7 个新特性：</p>
<ul>
<li><a href="https://openjdk.org/jeps/429">JEP 429：Scoped Values（作用域值）</a>（第一次孵化）</li>
<li><a href="https://openjdk.org/jeps/432">JEP 432：Record Patterns（记录模式）</a>（第二次预览）</li>
<li><a href="https://openjdk.org/jeps/433">JEP 433：switch 模式匹配</a>（第四次预览）</li>
<li><a href="https://openjdk.org/jeps/434">JEP 434: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次预览）</li>
<li><a href="https://openjdk.org/jeps/436">JEP 436: Virtual Threads（虚拟线程）</a>（第二次预览）</li>
<li><a href="https://openjdk.org/jeps/437">JEP 437:Structured Concurrency（结构化并发）</a>(第二次孵化)</li>
<li><a href="https://openjdk.org/jeps/438">JEP 432:向量 API（</a>第五次孵化）</li>
</ul>
<h2 id="JEP-429：作用域值（第一次孵化）"><a href="#JEP-429：作用域值（第一次孵化）" class="headerlink" title="JEP 429：作用域值（第一次孵化）"></a>JEP 429：作用域值（第一次孵化）</h2><p>作用域值（Scoped Values）它可以在线程内和线程间共享不可变的数据，优于线程局部变量，尤其是在使用大量虚拟线程时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> ScopedValue&lt;...&gt; V = <span class="keyword">new</span> ScopedValue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In some method</span></span><br><span class="line">ScopedValue.where(V, &lt;value&gt;)</span><br><span class="line">           .run(() -&gt; &#123; ... V.get() ... call methods ... &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In a method called directly or indirectly from the lambda expression</span></span><br><span class="line">... V.get() ...</span><br></pre></td></tr></table></figure>

<p>作用域值允许在大型程序中的组件之间安全有效地共享数据，而无需求助于方法参数。</p>
<p>关于作用域值的详细介绍，推荐阅读<a href="https://www.happycoders.eu/java/scoped-values/">作用域值常见问题解答</a>这篇文章。</p>
<h2 id="JEP-432：记录模式（第二次预览）"><a href="#JEP-432：记录模式（第二次预览）" class="headerlink" title="JEP 432：记录模式（第二次预览）"></a>JEP 432：记录模式（第二次预览）</h2><p>记录模式（Record Patterns） 可对 record 的值进行解构，也就是更方便地从记录类（Record Class）中提取数据。并且，还可以嵌套记录模式和类型模式结合使用，以实现强大的、声明性的和可组合的数据导航和处理形式。</p>
<p>记录模式不能单独使用，而是要与 instanceof 或 switch 模式匹配一同使用。</p>
<p>先以 instanceof 为例简单演示一下。</p>
<p>简单定义一个记录类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Shape</span><span class="params">(String type, <span class="keyword">long</span> unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>没有记录模式之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shape circle = <span class="keyword">new</span> Shape(<span class="string">&quot;Circle&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (circle <span class="keyword">instanceof</span> Shape shape) &#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;Area of &quot;</span> + shape.type() + <span class="string">&quot; is : &quot;</span> + Math.PI * Math.pow(shape.unit(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了记录模式之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape circle = <span class="keyword">new</span> Shape(<span class="string">&quot;Circle&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="function">circle <span class="keyword">instanceof</span> <span class="title">Shape</span><span class="params">(String type, <span class="keyword">long</span> unit)</span>) </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Area of &quot;</span> + type + <span class="string">&quot; is : &quot;</span> + Math.PI * Math.pow(unit, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看记录模式与 switch 的配合使用。</p>
<p>定义一些类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> implements Shape </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side)</span> implements Shape </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> implements Shape </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>没有记录模式之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Shape shape = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> Circle c:</span><br><span class="line">        System.out.println(<span class="string">&quot;The shape is Circle with area: &quot;</span> + Math.PI * c.radius() * c.radius());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Square s:</span><br><span class="line">        System.out.println(<span class="string">&quot;The shape is Square with area: &quot;</span> + s.side() * s.side());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Rectangle r:</span><br><span class="line">        System.out.println(<span class="string">&quot;The shape is Rectangle with area: + &quot;</span> + r.length() * r.width());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown Shape&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了记录模式之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shape shape = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">switch</span>(shape) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span>:</span></span><br><span class="line"><span class="function">    System.out.<span class="title">println</span><span class="params">(<span class="string">&quot;The shape is Circle with area: &quot;</span> + Math.PI * radius * radius)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side)</span>:</span></span><br><span class="line"><span class="function">    System.out.<span class="title">println</span><span class="params">(<span class="string">&quot;The shape is Square with area: &quot;</span> + side * side)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span>:</span></span><br><span class="line"><span class="function">    System.out.<span class="title">println</span><span class="params">(<span class="string">&quot;The shape is Rectangle with area: + &quot;</span> + length * width)</span></span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;Unknown Shape&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录模式可以避免不必要的转换，使得代码更建简洁易读。而且，用了记录模式后不必再担心 <code>null</code> 或者 <code>NullPointerException</code>，代码更安全可靠。</p>
<p>记录模式在 Java 19 进行了第一次预览， 由 <a href="https://openjdk.org/jeps/405">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/432">JEP 432</a> 提出。这次的改进包括：</p>
<ul>
<li>添加对通用记录模式类型参数推断的支持，</li>
<li>添加对记录模式的支持以出现在增强语句的标题中<code>for</code></li>
<li>删除对命名记录模式的支持。</li>
</ul>
<p><strong>注意</strong>：不要把记录模式和 <a href="./java16.md">JDK16</a> 正式引入的记录类搞混了。</p>
<h2 id="JEP-433：switch-模式匹配（第四次预览）"><a href="#JEP-433：switch-模式匹配（第四次预览）" class="headerlink" title="JEP 433：switch 模式匹配（第四次预览）"></a>JEP 433：switch 模式匹配（第四次预览）</h2><p>正如 <code>instanceof</code> 一样， <code>switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>
<p><code>instanceof</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String)o;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatter</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    String formatted = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long l) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatterPatternSwitch</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 模式匹配分别在 Java17、Java18、Java19 中进行了预览，Java20 是第四次预览了。每一次的预览基本都会有一些小改进，这里就不细提了。</p>
<h2 id="JEP-434-外部函数和内存-API（第二次预览）"><a href="#JEP-434-外部函数和内存-API（第二次预览）" class="headerlink" title="JEP 434: 外部函数和内存 API（第二次预览）"></a>JEP 434: 外部函数和内存 API（第二次预览）</h2><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出。</p>
<p>JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/434">JEP 434</a> 提出，这次的改进包括：</p>
<ul>
<li><code>MemorySegment</code> 和 <code>MemoryAddress</code> 抽象的统一</li>
<li>增强的 <code>MemoryLayout</code> 层次结构</li>
<li><code>MemorySession</code>拆分为<code>Arena</code>和<code>SegmentScope</code>，以促进跨维护边界的段共享。</li>
</ul>
<p>在 <a href="./java19.md">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>
<h2 id="JEP-436-虚拟线程（第二次预览）"><a href="#JEP-436-虚拟线程（第二次预览）" class="headerlink" title="JEP 436: 虚拟线程（第二次预览）"></a>JEP 436: 虚拟线程（第二次预览）</h2><p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>
<p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程，也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>
<p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：<a href="https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7">How to Use Java 19 Virtual Threads</a>）：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png" alt="虚拟线程、平台线程和系统内核线程的关系"></p>
<p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: <a href="https://www.zhihu.com/question/23096638/answer/29617153">JVM 中的线程模型是用户级的么？</a>。</p>
<p>相比较于平台线程来说，虚拟线程是廉价且轻量级的，使用完后立即被销毁，因此它们不需要被重用或池化，每个任务可以有自己专属的虚拟线程来运行。虚拟线程暂停和恢复来实现线程之间的切换，避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>
<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>
<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：<a href="https://www.zhihu.com/question/536743167">https://www.zhihu.com/question/536743167</a> 。</p>
<p>Java 虚拟线程的详细解读和原理可以看下面这几篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程极简入门</a></li>
<li><a href="https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>
<li><a href="https://www.cnblogs.com/throwable/p/16758997.html">虚拟线程 - VirtualThread 源码透视</a></li>
</ul>
<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href="https://openjdk.org/jeps/425">JEP 425</a>提出。JDK 20 中是第二次预览，做了一些细微变化，这里就不细提了。</p>
<p>最后，我们来看一下四种创建虚拟线程的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、通过 Thread.ofVirtual() 创建</span></span><br><span class="line">Runnable fn = () -&gt; &#123;</span><br><span class="line">  <span class="comment">// your code here</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread = Thread.ofVirtual(fn)</span><br><span class="line">                      .start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、通过 Thread.startVirtualThread() 、创建</span></span><br><span class="line">Thread thread = Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、通过 Executors.newVirtualThreadPerTaskExecutor() 创建</span></span><br><span class="line"><span class="keyword">var</span> executorService = Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CustomThread run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、通过 ThreadFactory 创建</span></span><br><span class="line">CustomThread customThread = <span class="keyword">new</span> CustomThread();</span><br><span class="line"><span class="comment">// 获取线程工厂类</span></span><br><span class="line">ThreadFactory factory = Thread.ofVirtual().factory();</span><br><span class="line"><span class="comment">// 创建虚拟线程</span></span><br><span class="line">Thread thread = factory.newThread(customThread);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>通过上述列举的 4 种创建虚拟线程的方式可以看出，官方为了降低虚拟线程的门槛，尽力复用原有的 <code>Thread</code> 线程类，这样可以平滑的过渡到虚拟线程的使用。</p>
<h2 id="JEP-437-结构化并发-第二次孵化"><a href="#JEP-437-结构化并发-第二次孵化" class="headerlink" title="JEP 437: 结构化并发(第二次孵化)"></a>JEP 437: 结构化并发(第二次孵化)</h2><p>Java 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>
<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>
<p>结构化并发的基本 API 是<a href="https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"><code>StructuredTaskScope</code></a>。<code>StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>
<p><code>StructuredTaskScope</code> 的基本用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> scope = <span class="keyword">new</span> StructuredTaskScope&lt;Object&gt;()) &#123;</span><br><span class="line">    <span class="comment">// 使用fork方法派生线程来执行子任务</span></span><br><span class="line">    Future&lt;Integer&gt; future1 = scope.fork(task1);</span><br><span class="line">    Future&lt;String&gt; future2 = scope.fork(task2);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    scope.join();</span><br><span class="line">    <span class="comment">// 结果的处理可能包括处理或重新抛出异常</span></span><br><span class="line">    ... process results/exceptions ...</span><br><span class="line">&#125; <span class="comment">// close</span></span><br></pre></td></tr></table></figure>

<p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>
<p>JDK 20 中对结构化并发唯一变化是更新为支持在任务范围内创建的线程<code>StructuredTaskScope</code>继承范围值 这简化了跨线程共享不可变数据，详见<a href="https://openjdk.org/jeps/429">JEP 429</a>。</p>
<h2 id="JEP-432：向量-API（第五次孵化）"><a href="#JEP-432：向量-API（第五次孵化）" class="headerlink" title="JEP 432：向量 API（第五次孵化）"></a>JEP 432：向量 API（第五次孵化）</h2><p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>
<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>
<p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>
<p>Java20 的这次孵化基本没有改变向量 API ，只是进行了一些错误修复和性能增强，详见 <a href="https://openjdk.org/jeps/438">JEP 438</a>。</p>
<h1 id="Java19-新特性"><a href="#Java19-新特性" class="headerlink" title="Java19 新特性"></a>Java19 新特性</h1><p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。</p>
<p>JDK 19 只有 7 个新特性：</p>
<ul>
<li><a href="https://openjdk.org/jeps/405">JEP 405: Record Patterns（记录模式）</a>（预览）</li>
<li><a href="https://openjdk.org/jeps/422">JEP 422: Linux/RISC-V Port</a></li>
<li><a href="https://openjdk.org/jeps/424">JEP 424: Foreign Function &amp; Memory API（外部函数和内存 API）</a>（预览）</li>
<li><a href="https://openjdk.org/jeps/425">JEP 425: Virtual Threads（虚拟线程）</a>（预览）</li>
<li><a href="https://openjdk.java.net/jeps/426">JEP 426: Vector（向量）API</a>（第四次孵化）</li>
<li><a href="https://openjdk.java.net/jeps/427">JEP 427: Pattern Matching for switch（switch 模式匹配）</a></li>
<li><a href="https://openjdk.org/jeps/428">JEP 428: Structured Concurrency（结构化并发）</a>（孵化）</li>
</ul>
<p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。</p>
<p>相关阅读：<a href="https://openjdk.org/projects/jdk/19/">OpenJDK Java 19 文档</a></p>
<h2 id="JEP-424-外部函数和内存-API（预览）"><a href="#JEP-424-外部函数和内存-API（预览）" class="headerlink" title="JEP 424: 外部函数和内存 API（预览）"></a>JEP 424: 外部函数和内存 API（预览）</h2><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>
<p>在没有外部函数和内存 API 之前：</p>
<ul>
<li>Java 通过 <a href="https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java"><code>sun.misc.Unsafe</code></a> 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），<code>Unsafe</code> 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 <code>Unsafe</code> 类会使得程序出错的概率变大。</li>
<li>Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章：<a href="https://www.baeldung.com/jni">Guide to JNI (Java Native Interface)</a> ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然<a href="https://github.com/java-native-access/jna">JNA</a>、<a href="https://github.com/jnr/jnr-ffi">JNR</a>和<a href="https://github.com/bytedeco/javacpp">JavaCPP</a>等框架对 JNI 进行了改进，但效果还是不太理想。</li>
</ul>
<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p>
<p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p>
<ul>
<li>分配外部内存：<code>MemorySegment</code>、、<code>MemoryAddress</code>和<code>SegmentAllocator</code>）；</li>
<li>操作和访问结构化的外部内存：<code>MemoryLayout</code>, <code>VarHandle</code>；</li>
<li>控制外部内存的分配和释放：<code>MemorySession</code>；</li>
<li>调用外部函数：<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>。</li>
</ul>
<p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code>radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在C库路径上查找外部函数</span></span><br><span class="line">Linker linker = Linker.nativeLinker();</span><br><span class="line">SymbolLookup stdlib = linker.defaultLookup();</span><br><span class="line">MethodHandle radixSort = linker.downcallHandle(</span><br><span class="line">                             stdlib.lookup(<span class="string">&quot;radixsort&quot;</span>), ...);</span><br><span class="line"><span class="comment">// 2. 分配堆上内存以存储四个字符串</span></span><br><span class="line">String[] javaStrings   = &#123; <span class="string">&quot;mouse&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;car&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 3. 分配堆外内存以存储四个指针</span></span><br><span class="line">SegmentAllocator allocator = implicitAllocator();</span><br><span class="line">MemorySegment offHeap  = allocator.allocateArray(ValueLayout.ADDRESS, javaStrings.length);</span><br><span class="line"><span class="comment">// 4. 将字符串从堆上复制到堆外</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; javaStrings.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 在堆外分配一个字符串，然后存储指向它的指针</span></span><br><span class="line">    MemorySegment cString = allocator.allocateUtf8String(javaStrings[i]);</span><br><span class="line">    offHeap.setAtIndex(ValueLayout.ADDRESS, i, cString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 通过调用外部函数对堆外数据进行排序</span></span><br><span class="line">radixSort.invoke(offHeap, javaStrings.length, MemoryAddress.NULL, <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"><span class="comment">// 6. 将(重新排序的)字符串从堆外复制到堆上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; javaStrings.length; i++) &#123;</span><br><span class="line">    MemoryAddress cStringPtr = offHeap.getAtIndex(ValueLayout.ADDRESS, i);</span><br><span class="line">    javaStrings[i] = cStringPtr.getUtf8String(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> Arrays.equals(javaStrings, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;car&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;mouse&quot;</span>&#125;);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="JEP-425-虚拟线程（预览）"><a href="#JEP-425-虚拟线程（预览）" class="headerlink" title="JEP 425: 虚拟线程（预览）"></a>JEP 425: 虚拟线程（预览）</h2><p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>
<p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p>
<p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>
<p>知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看：<a href="https://www.zhihu.com/question/536743167">https://www.zhihu.com/question/536743167</a> 。</p>
<p>Java 虚拟线程的详细解读和原理可以看下面这两篇文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/vdLXhZdWyxc6K-D3Aj03LA">虚拟线程原理及性能分析｜得物技术</a></li>
<li><a href="https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q">Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量</a></li>
<li><a href="https://www.cnblogs.com/throwable/p/16758997.html">虚拟线程 - VirtualThread 源码透视</a></li>
</ul>
<h2 id="JEP-426-向量-API（第四次孵化）"><a href="#JEP-426-向量-API（第四次孵化）" class="headerlink" title="JEP 426: 向量 API（第四次孵化）"></a>JEP 426: 向量 API（第四次孵化）</h2><p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>
<p>在 <a href="./java18.md">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>
<h2 id="JEP-428-结构化并发-孵化"><a href="#JEP-428-结构化并发-孵化" class="headerlink" title="JEP 428: 结构化并发(孵化)"></a>JEP 428: 结构化并发(孵化)</h2><p>JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代<code>java.util.concurrent</code>，目前处于孵化器阶段。</p>
<p>结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。</p>
<p>结构化并发的基本 API 是<a href="https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html"><code>StructuredTaskScope</code></a>。<code>StructuredTaskScope</code> 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。</p>
<p><code>StructuredTaskScope</code> 的基本用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> scope = <span class="keyword">new</span> StructuredTaskScope&lt;Object&gt;()) &#123;</span><br><span class="line">    <span class="comment">// 使用fork方法派生线程来执行子任务</span></span><br><span class="line">    Future&lt;Integer&gt; future1 = scope.fork(task1);</span><br><span class="line">    Future&lt;String&gt; future2 = scope.fork(task2);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    scope.join();</span><br><span class="line">    <span class="comment">// 结果的处理可能包括处理或重新抛出异常</span></span><br><span class="line">    ... process results/exceptions ...</span><br><span class="line">&#125; <span class="comment">// close</span></span><br></pre></td></tr></table></figure>

<p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>
<h1 id="Java18-新特性"><a href="#Java18-新特性" class="headerlink" title="Java18 新特性"></a>Java18 新特性</h1><p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。</p>
<p>Java 18 带来了 9 个新特性：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/400">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）</a></li>
<li><a href="https://openjdk.java.net/jeps/408">JEP 408:Simple Web Server（简易的 Web 服务器）</a></li>
<li><a href="https://openjdk.java.net/jeps/413">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）</a></li>
<li><a href="https://openjdk.java.net/jeps/416">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）</a></li>
<li><a href="https://openjdk.java.net/jeps/417">JEP 417:Vector（向量） API</a>（第三次孵化）</li>
<li><a href="https://openjdk.java.net/jeps/418">JEP 418:Internet-Address Resolution（互联网地址解析）SPI</a></li>
<li><a href="https://openjdk.java.net/jeps/419">JEP 419:Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第二次孵化）</li>
<li><a href="https://openjdk.java.net/jeps/420">JEP 420:Pattern Matching for switch（switch 模式匹配）</a>（第二次预览）</li>
<li><a href="https://openjdk.java.net/jeps/421">JEP 421:Deprecate Finalization for Removal</a></li>
</ul>
<p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。</p>
<p>这里只对 400、408、413、416、417、418、419 这几个我觉得比较重要的新特性进行详细介绍。</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://openjdk.java.net/projects/jdk/18/">OpenJDK Java 18 文档</a></li>
<li><a href="https://mp.weixin.qq.com/s/PocFKR9z9u7-YCZHsrA5kQ">IntelliJ IDEA | Java 18 功能支持</a></li>
</ul>
<h2 id="JEP-400-默认字符集为-UTF-8"><a href="#JEP-400-默认字符集为-UTF-8" class="headerlink" title="JEP 400:默认字符集为 UTF-8"></a>JEP 400:默认字符集为 UTF-8</h2><p>JDK 终于将 UTF-8 设置为默认字符集。</p>
<p>在 Java 17 及更早版本中，默认字符集是在 Java 虚拟机运行时才确定的，取决于不同的操作系统、区域设置等因素，因此存在潜在的风险。就比如说你在 Mac 上运行正常的一段打印文字到控制台的 Java 程序到了 Windows 上就会出现乱码，如果你不手动更改字符集的话。</p>
<h2 id="JEP-408-简易的-Web-服务器"><a href="#JEP-408-简易的-Web-服务器" class="headerlink" title="JEP 408:简易的 Web 服务器"></a>JEP 408:简易的 Web 服务器</h2><p>Java 18 之后，你可以使用 <code>jwebserver</code> 命令启动一个简易的静态 Web 服务器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jwebserver</span><br><span class="line">Binding to loopback by default. For all interfaces use <span class="string">&quot;-b 0.0.0.0&quot;</span> or <span class="string">&quot;-b ::&quot;</span>.</span><br><span class="line">Serving /cwd and subdirectories on 127.0.0.1 port 8000</span><br><span class="line">URL: http://127.0.0.1:8000/</span><br></pre></td></tr></table></figure>

<p>这个服务器不支持 CGI 和 Servlet，只限于静态文件。</p>
<h2 id="JEP-413-优化-Java-API-文档中的代码片段"><a href="#JEP-413-优化-Java-API-文档中的代码片段" class="headerlink" title="JEP 413:优化 Java API 文档中的代码片段"></a>JEP 413:优化 Java API 文档中的代码片段</h2><p>在 Java 18 之前，如果我们想要在 Javadoc 中引入代码片段可以使用 <code>&lt;pre&gt;&#123;@code ...&#125;&lt;/pre&gt;</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&#123;<span class="meta">@code</span></span><br><span class="line">    lines of source code</span><br><span class="line">&#125;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;pre&gt;&#123;@code ...&#125;&lt;/pre&gt;</code> 这种方式生成的效果比较一般。</p>
<p>在 Java 18 之后，可以通过 <code>@snippet</code> 标签来做这件事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The following code shows how to use &#123;<span class="doctag">@code</span> Optional.isPresent&#125;:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@snippet</span> :</span></span><br><span class="line"><span class="comment"> * if (v.isPresent()) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(&quot;v: &quot; + v.get());</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>@snippet</code> 这种方式生成的效果更好且使用起来更方便一些。</p>
<h2 id="JEP-416-使用方法句柄重新实现反射核心"><a href="#JEP-416-使用方法句柄重新实现反射核心" class="headerlink" title="JEP 416:使用方法句柄重新实现反射核心"></a>JEP 416:使用方法句柄重新实现反射核心</h2><p>Java 18 改进了 <code>java.lang.reflect.Method</code>、<code>Constructor</code> 的实现逻辑，使之性能更好，速度更快。这项改动不会改动相关 API ，这意味着开发中不需要改动反射相关代码，就可以体验到性能更好反射。</p>
<p>OpenJDK 官方给出了新老实现的反射性能基准测试结果。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/JEP416Benchmark.png" alt="新老实现的反射性能基准测试结果"></p>
<h2 id="JEP-417-向量-API（第三次孵化）"><a href="#JEP-417-向量-API（第三次孵化）" class="headerlink" title="JEP 417: 向量 API（第三次孵化）"></a>JEP 417: 向量 API（第三次孵化）</h2><p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>
<p>向量计算由对向量的一系列操作组成。向量 API 用来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。</p>
<p>向量 API 的目标是为用户提供简洁易用且与平台无关的表达范围广泛的向量计算。</p>
<p>这是对数组元素的简单标量计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scalarComputation</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">float</span>[] b, <span class="keyword">float</span>[] c)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -<span class="number">1.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是使用 Vector API 进行的等效向量计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_PREFERRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vectorComputation</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">float</span>[] b, <span class="keyword">float</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> upperBound = SPECIES.loopBound(a.length);</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; upperBound; i += SPECIES.length()) &#123;</span><br><span class="line">        <span class="comment">// FloatVector va, vb, vc;</span></span><br><span class="line">        <span class="keyword">var</span> va = FloatVector.fromArray(SPECIES, a, i);</span><br><span class="line">        <span class="keyword">var</span> vb = FloatVector.fromArray(SPECIES, b, i);</span><br><span class="line">        <span class="keyword">var</span> vc = va.mul(va)</span><br><span class="line">                   .add(vb.mul(vb))</span><br><span class="line">                   .neg();</span><br><span class="line">        vc.intoArray(c, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; a.length; i++) &#123;</span><br><span class="line">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -<span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 JDK 18 中，向量 API 的性能得到了进一步的优化。</p>
<h2 id="JEP-418-互联网地址解析-SPI"><a href="#JEP-418-互联网地址解析-SPI" class="headerlink" title="JEP 418:互联网地址解析 SPI"></a>JEP 418:互联网地址解析 SPI</h2><p>Java 18 定义了一个全新的 SPI（service-provider interface），用于主要名称和地址的解析，以便 <code>java.net.InetAddress</code> 可以使用平台之外的第三方解析器。</p>
<h2 id="JEP-419-Foreign-Function-amp-Memory-API（第二次孵化）"><a href="#JEP-419-Foreign-Function-amp-Memory-API（第二次孵化）" class="headerlink" title="JEP 419:Foreign Function &amp; Memory API（第二次孵化）"></a>JEP 419:Foreign Function &amp; Memory API（第二次孵化）</h2><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>
<h1 id="Java17-新特性"><a href="#Java17-新特性" class="headerlink" title="Java17 新特性"></a>Java17 新特性</h1><p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。</p>
<p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java</p>
<p>17 最多可以支持到 2029 年 9 月份。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png"></p>
<p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。</p>
<p>这次更新共带来 14 个新特性：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/306">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）</a></li>
<li><a href="https://openjdk.java.net/jeps/356">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）</a></li>
<li><a href="https://openjdk.java.net/jeps/382">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）</a></li>
<li><a href="https://openjdk.java.net/jeps/391">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）</a></li>
<li><a href="https://openjdk.java.net/jeps/398">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）</a></li>
<li><a href="https://openjdk.java.net/jeps/403">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）</a></li>
<li><a href="https://openjdk.java.net/jeps/406">JEP 406:Pattern Matching for switch (switch 的类型匹配)</a>（预览）</li>
<li><a href="https://openjdk.java.net/jeps/407">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）</a></li>
<li><a href="https://openjdk.java.net/jeps/409">JEP 409:Sealed Classes（密封类）</a>（转正）</li>
<li><a href="https://openjdk.java.net/jeps/410">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）</a></li>
<li><a href="https://openjdk.java.net/jeps/411">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）</a></li>
<li><a href="https://openjdk.java.net/jeps/412">JEP 412:Foreign Function &amp; Memory API (外部函数和内存 API)</a>（孵化）</li>
<li><a href="https://openjdk.java.net/jeps/417">JEP 414:Vector（向量） API</a>（第二次孵化）</li>
<li><a href="https://openjdk.java.net/jeps/415">JEP 415:Context-Specific Deserialization Filters</a></li>
</ul>
<p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。</p>
<p>相关阅读：<a href="https://openjdk.java.net/projects/jdk/17/">OpenJDK Java 17 文档</a> 。</p>
<h2 id="JEP-356-增强的伪随机数生成器"><a href="#JEP-356-增强的伪随机数生成器" class="headerlink" title="JEP 356:增强的伪随机数生成器"></a>JEP 356:增强的伪随机数生成器</h2><p>JDK 17 之前，我们可以借助 <code>Random</code>、<code>ThreadLocalRandom</code>和<code>SplittableRandom</code>来生成随机数。不过，这 3 个类都各有缺陷，且缺少常见的伪随机算法支持。</p>
<p>Java 17 为伪随机数生成器 （pseudorandom number generator，PRNG，又称为确定性随机位生成器）增加了新的接口类型和实现，使得开发者更容易在应用程序中互换使用各种 PRNG 算法。</p>
<blockquote>
<p><a href="https://ctf-wiki.org/crypto/streamcipher/prng/intro/">PRNG</a> 用来生成接近于绝对随机数序列的数字序列。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RandomGeneratorFactory&lt;RandomGenerator&gt; l128X256MixRandom = RandomGeneratorFactory.of(<span class="string">&quot;L128X256MixRandom&quot;</span>);</span><br><span class="line"><span class="comment">// 使用时间戳作为随机数种子</span></span><br><span class="line">RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis());</span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line">randomGenerator.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JEP-398-弃用-Applet-API-以进行删除"><a href="#JEP-398-弃用-Applet-API-以进行删除" class="headerlink" title="JEP 398:弃用 Applet API 以进行删除"></a>JEP 398:弃用 Applet API 以进行删除</h2><p>Applet API 用于编写在 Web 浏览器端运行的 Java 小程序，很多年前就已经被淘汰了，已经没有理由使用了。</p>
<p>Applet API 在 Java 9 时被标记弃用（<a href="https://openjdk.java.net/jeps/289">JEP 289</a>），但不是为了删除。</p>
<h2 id="JEP-406-switch-的类型匹配（预览）"><a href="#JEP-406-switch-的类型匹配（预览）" class="headerlink" title="JEP 406:switch 的类型匹配（预览）"></a>JEP 406:switch 的类型匹配（预览）</h2><p>正如 <code>instanceof</code> 一样， <code>switch</code> 也紧跟着增加了类型匹配自动转换功能。</p>
<p><code>instanceof</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String)o;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatter</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    String formatted = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long l) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">formatterPatternSwitch</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 <code>null</code> 值的判断也进行了优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFooBar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;oops!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span> -&gt; System.out.println(<span class="string">&quot;Great&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>           -&gt; System.out.println(<span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFooBar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">null</span>         -&gt; System.out.println(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span> -&gt; System.out.println(<span class="string">&quot;Great&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>           -&gt; System.out.println(<span class="string">&quot;Ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JEP-407-删除远程方法调用激活机制"><a href="#JEP-407-删除远程方法调用激活机制" class="headerlink" title="JEP 407:删除远程方法调用激活机制"></a>JEP 407:删除远程方法调用激活机制</h2><p>删除远程方法调用 (RMI) 激活机制，同时保留 RMI 的其余部分。RMI 激活机制已过时且不再使用。</p>
<h2 id="JEP-409-密封类（转正）"><a href="#JEP-409-密封类（转正）" class="headerlink" title="JEP 409:密封类（转正）"></a>JEP 409:密封类（转正）</h2><p>密封类由 <a href="https://openjdk.java.net/jeps/360">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href="https://openjdk.java.net/jeps/397">JEP 397</a> 提出了再次预览。</p>
<p>在 Java 14 &amp; 15 新特性概览 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>
<h2 id="JEP-410-删除实验性的-AOT-和-JIT-编译器"><a href="#JEP-410-删除实验性的-AOT-和-JIT-编译器" class="headerlink" title="JEP 410:删除实验性的 AOT 和 JIT 编译器"></a>JEP 410:删除实验性的 AOT 和 JIT 编译器</h2><p>在 Java 9 的 <a href="https://openjdk.java.net/jeps/295">JEP 295</a> ,引入了实验性的提前 (AOT) 编译器，在启动虚拟机之前将 Java 类编译为本机代码。</p>
<p>Java 17，删除实验性的提前 (AOT) 和即时 (JIT) 编译器，因为该编译器自推出以来很少使用，维护它所需的工作量很大。保留实验性的 Java 级 JVM 编译器接口 (JVMCI)，以便开发人员可以继续使用外部构建的编译器版本进行 JIT 编译。</p>
<h2 id="JEP-411-弃用安全管理器以进行删除"><a href="#JEP-411-弃用安全管理器以进行删除" class="headerlink" title="JEP 411:弃用安全管理器以进行删除"></a>JEP 411:弃用安全管理器以进行删除</h2><p>弃用安全管理器以便在将来的版本中删除。</p>
<p>安全管理器可追溯到 Java 1.0，多年来，它一直不是保护客户端 Java 代码的主要方法，也很少用于保护服务器端代码。为了推动 Java 向前发展，Java 17 弃用安全管理器，以便与旧版 Applet API ( <a href="https://openjdk.java.net/jeps/398">JEP 398</a> ) 一起移除。</p>
<h2 id="JEP-412-外部函数和内存-API（孵化）"><a href="#JEP-412-外部函数和内存-API（孵化）" class="headerlink" title="JEP 412:外部函数和内存 API（孵化）"></a>JEP 412:外部函数和内存 API（孵化）</h2><p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412">JEP 412</a> 提出。第二轮孵化由<a href="https://openjdk.org/jeps/419">JEP 419</a> 提出并集成到了 Java 18 中，预览由 <a href="https://openjdk.org/jeps/424">JEP 424</a> 提出并集成到了 Java 19 中。</p>
<p>在 Java 19 新特性概览 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>
<h2 id="JEP-414-向量-API（第二次孵化）"><a href="#JEP-414-向量-API（第二次孵化）" class="headerlink" title="JEP 414:向量 API（第二次孵化）"></a>JEP 414:向量 API（第二次孵化）</h2><p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>
<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>
<p>在 Java 18 新特性概览 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>
<h1 id="Java16-新特性"><a href="#Java16-新特性" class="headerlink" title="Java16 新特性"></a>Java16 新特性</h1><p>Java 16 在 2021 年 3 月 16 日正式发布，非长期支持（LTS）版本。</p>
<p>相关阅读：<a href="https://openjdk.java.net/projects/jdk/16/">OpenJDK Java 16 文档</a> 。</p>
<h2 id="JEP-338-向量-API-第一次孵化"><a href="#JEP-338-向量-API-第一次孵化" class="headerlink" title="JEP 338:向量 API(第一次孵化)"></a>JEP 338:向量 API(第一次孵化)</h2><p>向量（Vector） API 最初由 <a href="https://openjdk.java.net/jeps/338">JEP 338</a> 提出，并作为<a href="http://openjdk.java.net/jeps/11">孵化 API</a>集成到 Java 16 中。第二轮孵化由 <a href="https://openjdk.java.net/jeps/414">JEP 414</a> 提出并集成到 Java 17 中，第三轮孵化由 <a href="https://openjdk.java.net/jeps/417">JEP 417</a> 提出并集成到 Java 18 中，第四轮由 <a href="https://openjdk.java.net/jeps/426">JEP 426</a> 提出并集成到了 Java 19 中。</p>
<p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。</p>
<p>在 <a href="./java18.md">Java 18 新特性概览</a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。</p>
<h2 id="JEP-347-启用-C-14-语言特性"><a href="#JEP-347-启用-C-14-语言特性" class="headerlink" title="JEP 347:启用 C++ 14 语言特性"></a>JEP 347:启用 C++ 14 语言特性</h2><p>Java 16 允许在 JDK 的 C++ 源代码中使用 C++14 语言特性，并提供在 HotSpot 代码中可以使用哪些特性的具体指导。</p>
<p>在 Java 15 中，JDK 中 C++ 代码使用的语言特性仅限于 C++98/03 语言标准。它要求更新各种平台编译器的最低可接受版本。</p>
<h2 id="JEP-376-ZGC-并发线程堆栈处理"><a href="#JEP-376-ZGC-并发线程堆栈处理" class="headerlink" title="JEP 376:ZGC 并发线程堆栈处理"></a>JEP 376:ZGC 并发线程堆栈处理</h2><p>Java16 将 ZGC 线程栈处理从安全点转移到一个并发阶段，甚至在大堆上也允许在毫秒内暂停 GC 安全点。消除 ZGC 垃圾收集器中最后一个延迟源可以极大地提高应用程序的性能和效率。</p>
<h2 id="JEP-387-弹性元空间"><a href="#JEP-387-弹性元空间" class="headerlink" title="JEP 387:弹性元空间"></a>JEP 387:弹性元空间</h2><p>自从引入了 Metaspace 以来，根据反馈，Metaspace 经常占用过多的堆外内存，从而导致内存浪费。弹性元空间这个特性可将未使用的 HotSpot 类元数据（即元空间，metaspace）内存更快速地返回到操作系统，从而减少元空间的占用空间。</p>
<p>并且，这个提案还简化了元空间的代码以降低维护成本。</p>
<h2 id="JEP-390-对基于值的类发出警告"><a href="#JEP-390-对基于值的类发出警告" class="headerlink" title="JEP 390:对基于值的类发出警告"></a>JEP 390:对基于值的类发出警告</h2><blockquote>
<p>以下介绍摘自：<a href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116">实操 | 剖析 Java16 新语法特性</a>，原文写的很不错，推荐阅读。</p>
</blockquote>
<p>早在 Java9 版本时，Java 的设计者们就对 <code>@Deprecated</code> 注解进行了一次升级，增加了 <code>since</code> 和 <code>forRemoval</code> 等 2 个新元素。其中，since 元素用于指定标记了 <code>@Deprecated</code> 注解的 API 被弃用时的版本，而 <code>forRemoval</code> 则进一步明确了 API 标记 @Deprecated 注解时的语义，如果<code>forRemoval=true</code>时，则表示该 API 在未来版本中肯定会被删除，开发人员应该使用新的 API 进行替代，不再容易产生歧义（Java9 之前，标记 @Deprecated 注解的 API，语义上存在多种可能性，比如：存在使用风险、可能在未来存在兼容性错误、可能在未来版本中被删除，以及应该使用更好的替代方案等）。</p>
<p>仔细观察原始类型的包装类（比如：<code>java.lang.Integer</code>、<code>java.lang.Double</code>），不难发现，其构造函数上都已经标记有<code>@Deprecated(since=&quot;9&quot;, forRemoval = true)</code>注解，这就意味着其构造函数在将来会被删除，不应该在程序中继续使用诸如<code>new Integer();</code>这样的编码方式（建议使用<code>Integer a = 10;</code>或者<code>Integer.valueOf()</code>函数），如果继续使用，编译期将会产生’Integer(int)’ is deprecated and marked for removal 告警。并且，值得注意的是，这些包装类型已经被指定为同 <code>java.util.Optional</code> 和 <code>java.time.LocalDateTime</code> 一样的值类型。</p>
<p>其次，如果继续在 <code>synchronized</code> 同步块中使用值类型，将会在编译期和运行期产生警告，甚至是异常。在此大家需要注意，就算编译期和运行期没有产生警告和异常，也不建议在 <code>synchronized</code> 同步块中使用值类型，举个自增的例子。示例 1-5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(Integer count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (count) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行上述程序示例时，最终的输出结果一定会与你的期望产生差异，这是许多新人经常犯错的一个点，因为在并发环境下，<code>Integer</code> 对象根本无法通过 <code>synchronized</code> 来保证线程安全，这是因为每次的<code>count++</code>操作，所产生的 <code>hashcode</code> 均不同，简而言之，每次加锁都锁在了不同的对象上。因此，如果希望在实际的开发过程中保证其原子性，应该使用 <code>AtomicInteger</code>。</p>
<h2 id="JEP-392-打包工具"><a href="#JEP-392-打包工具" class="headerlink" title="JEP 392:打包工具"></a>JEP 392:打包工具</h2><p>在 Java 14 中，JEP 343 引入了打包工具，命令是 <code>jpackage</code>。在 Java 15 中，继续孵化，现在在 Java 16 中，终于成为了正式功能。</p>
<p>这个打包工具允许打包自包含的 Java 应用程序。它支持原生打包格式，为最终用户提供自然的安装体验，这些格式包括 Windows 上的 msi 和 exe、macOS 上的 pkg 和 dmg，还有 Linux 上的 deb 和 rpm。它还允许在打包时指定启动时参数，并且可以从命令行直接调用，也可以通过 ToolProvider API 以编程方式调用。注意 jpackage 模块名称从 jdk.incubator.jpackage 更改为 jdk.jpackage。这将改善最终用户在安装应用程序时的体验，并简化了“应用商店”模型的部署。</p>
<p>关于这个打包工具的实际使用，可以看这个视频 <a href="https://www.youtube.com/watch?v=KahYIVzRIkQ">Playing with Java 16 jpackage</a>（需要梯子）。</p>
<h2 id="JEP-393-外部内存访问-API-第三次孵化"><a href="#JEP-393-外部内存访问-API-第三次孵化" class="headerlink" title="JEP 393:外部内存访问 API(第三次孵化)"></a>JEP 393:外部内存访问 API(第三次孵化)</h2><p>引入外部内存访问 API 以允许 Java 程序安全有效地访问 Java 堆之外的外部内存。</p>
<p>Java 14(<a href="https://openjdk.org/jeps/370">JEP 370</a>) 的时候，第一次孵化外部内存访问 API，Java 15 中进行了第二次复活（<a href="https://openjdk.org/jeps/383">JEP 383</a>），在 Java 16 中进行了第三次孵化。</p>
<p>引入外部内存访问 API 的目的如下：</p>
<ul>
<li>通用：单个 API 应该能够对各种外部内存（如本机内存、持久内存、堆内存等）进行操作。</li>
<li>安全：无论操作何种内存，API 都不应该破坏 JVM 的安全性。</li>
<li>控制：可以自由的选择如何释放内存（显式、隐式等）。</li>
<li>可用：如果需要访问外部内存，API 应该是 <code>sun.misc.Unsafe</code>.</li>
</ul>
<h2 id="JEP-394-instanceof-模式匹配-转正"><a href="#JEP-394-instanceof-模式匹配-转正" class="headerlink" title="JEP 394:instanceof 模式匹配(转正)"></a>JEP 394:instanceof 模式匹配(转正)</h2><table>
<thead>
<tr>
<th>JDK 版本</th>
<th>更新类型</th>
<th>JEP</th>
<th>更新内容</th>
</tr>
</thead>
<tbody><tr>
<td>Java SE 14</td>
<td>preview</td>
<td><a href="https://openjdk.org/jeps/305">JEP 305</a></td>
<td>首次引入 instanceof 模式匹配。</td>
</tr>
<tr>
<td>Java SE 15</td>
<td>Second Preview</td>
<td><a href="https://openjdk.org/jeps/375">JEP 375</a></td>
<td>相比较上个版本无变化，继续收集更多反馈。</td>
</tr>
<tr>
<td>Java SE 16</td>
<td>Permanent Release</td>
<td><a href="https://openjdk.org/jeps/394">JEP 394</a></td>
<td>模式变量不再隐式为 final。</td>
</tr>
</tbody></table>
<p>从 Java 16 开始，你可以对 <code>instanceof</code> 中的变量值进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String s = (String)o;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    ... use s ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JEP-395-记录类型-转正"><a href="#JEP-395-记录类型-转正" class="headerlink" title="JEP 395:记录类型(转正)"></a>JEP 395:记录类型(转正)</h2><p>记录类型变更历史：</p>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>更新类型</th>
<th>JEP</th>
<th>更新内容</th>
</tr>
</thead>
<tbody><tr>
<td>Java SE 14</td>
<td>Preview</td>
<td><a href="https://openjdk.java.net/jeps/359">JEP 359</a></td>
<td>引入 <code>record</code> 关键字，<code>record</code> 提供一种紧凑的语法来定义类中的不可变数据。</td>
</tr>
<tr>
<td>Java SE 15</td>
<td>Second Preview</td>
<td><a href="https://openjdk.org/jeps/384">JEP 384</a></td>
<td>支持在局部方法和接口中使用 <code>record</code>。</td>
</tr>
<tr>
<td>Java SE 16</td>
<td>Permanent Release</td>
<td><a href="https://openjdk.org/jeps/395">JEP 395</a></td>
<td>非静态内部类可以定义非常量的静态成员。</td>
</tr>
</tbody></table>
<p>从 Java SE 16 开始，非静态内部类可以定义非常量的静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 JDK 16 之前，如果写上面这种代码，IDE 会提示你静态字段 age 不能在非静态的内部类中定义，除非它用一个常量表达式初始化。（The field age cannot be declared static in a non-static inner type, unless initialized with a constant expression）</p>
</blockquote>
<h2 id="JEP-396-默认强封装-JDK-内部元素"><a href="#JEP-396-默认强封装-JDK-内部元素" class="headerlink" title="JEP 396:默认强封装 JDK 内部元素"></a>JEP 396:默认强封装 JDK 内部元素</h2><p>此特性会默认强封装 JDK 的所有内部元素，但关键内部 API（例如 <code>sun.misc.Unsafe</code>）除外。默认情况下，使用早期版本成功编译的访问 JDK 内部 API 的代码可能不再起作用。鼓励开发人员从使用内部元素迁移到使用标准 API 的方法上，以便他们及其用户都可以无缝升级到将来的 Java 版本。强封装由 JDK 9 的启动器选项–illegal-access 控制，到 JDK 15 默认改为 warning，从 JDK 16 开始默认为 deny。（目前）仍然可以使用单个命令行选项放宽对所有软件包的封装，将来只有使用–add-opens 打开特定的软件包才行。</p>
<h2 id="JEP-397-密封类-预览"><a href="#JEP-397-密封类-预览" class="headerlink" title="JEP 397:密封类(预览)"></a>JEP 397:密封类(预览)</h2><p>密封类由 <a href="https://openjdk.java.net/jeps/360">JEP 360</a> 提出预览，集成到了 Java 15 中。在 JDK 16 中， 密封类得到了改进（更加严格的引用检查和密封类的继承关系），由 <a href="https://openjdk.java.net/jeps/397">JEP 397</a> 提出了再次预览。</p>
<p>在 <a href="./java14-15.md">Java 14 &amp; 15 新特性概览</a> 中，我有详细介绍到密封类，这里就不再做额外的介绍了。</p>
<h2 id="其他优化与改进"><a href="#其他优化与改进" class="headerlink" title="其他优化与改进"></a>其他优化与改进</h2><ul>
<li><strong>JEP 380:Unix-Domain 套接字通道</strong>：Unix-domain 套接字一直是大多数 Unix 平台的一个特性，现在在 Windows 10 和 Windows Server 2019 也提供了支持。此特性为 java.nio.channels 包的套接字通道和服务器套接字通道 API 添加了 Unix-domain（AF_UNIX）套接字支持。它扩展了继承的通道机制以支持 Unix-domain 套接字通道和服务器套接字通道。Unix-domain 套接字用于同一主机上的进程间通信（IPC）。它们在很大程度上类似于 TCP/IP，区别在于套接字是通过文件系统路径名而不是 Internet 协议（IP）地址和端口号寻址的。对于本地进程间通信，Unix-domain 套接字比 TCP/IP 环回连接更安全、更有效</li>
<li><strong>JEP 389:外部链接器 API(孵化)：</strong> 该孵化器 API 提供了静态类型、纯 Java 访问原生代码的特性，该 API 将大大简化绑定原生库的原本复杂且容易出错的过程。Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。Java 开发人员应该能够为特定任务绑定特定的原生库。它还提供了外来函数支持，而无需任何中间的 JNI 粘合代码。</li>
<li><strong>JEP 357:从 Mercurial 迁移到 Git</strong>：在此之前，OpenJDK 源代码是使用版本管理工具 Mercurial 进行管理，现在迁移到了 Git。</li>
<li><strong>JEP 369:迁移到 GitHub</strong>：和 JEP 357 从 Mercurial 迁移到 Git 的改变一致，在把版本管理迁移到 Git 之后，选择了在 GitHub 上托管 OpenJDK 社区的 Git 仓库。不过只对 JDK 11 以及更高版本 JDK 进行了迁移。</li>
<li><strong>JEP 386:移植 Alpine Linux</strong>：Alpine Linux 是一个独立的、非商业的 Linux 发行版，它十分的小，一个容器需要不超过 8MB 的空间，最小安装到磁盘只需要大约 130MB 存储空间，并且十分的简单，同时兼顾了安全性。此提案将 JDK 移植到了 Apline Linux，由于 Apline Linux 是基于 musl lib 的轻量级 Linux 发行版，因此其他 x64 和 AArch64 架构上使用 musl lib 的 Linux 发行版也适用。</li>
<li><strong>JEP 388:Windows/AArch64 移植</strong>：这些 JEP 的重点不是移植工作本身，而是将它们集成到 JDK 主线存储库中；JEP 386 将 JDK 移植到 Alpine Linux 和其他使用 musl 作为 x64 上主要 C 库的发行版上。此外，JEP 388 将 JDK 移植到 Windows AArch64（ARM64）。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://docs.oracle.com/en/java/javase/16/language/java-language-changes.html">Java Language Changes</a></li>
<li><a href="https://www.oracle.com/java/technologies/javase/16all-relnotes.html">Consolidated JDK 16 Release Notes</a></li>
<li><a href="https://www.infoq.cn/article/IAkwhx7i9V7G8zLVEd4L">Java 16 正式发布，新特性一一解析</a></li>
<li><a href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116">实操 | 剖析 Java16 新语法特性</a>（写的很赞）</li>
<li><h1 id="Java14-15-新特性"><a href="#Java14-15-新特性" class="headerlink" title="Java14~15 新特性"></a>Java14~15 新特性</h1></li>
</ul>
<h2 id="Java14"><a href="#Java14" class="headerlink" title="Java14"></a>Java14</h2><h3 id="空指针异常精准提示"><a href="#空指针异常精准提示" class="headerlink" title="空指针异常精准提示"></a>空指针异常精准提示</h3><p>通过 JVM 参数中添加<code>-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.i = <span class="number">99</span>; <span class="comment">// 假设这段代码会发生空指针</span></span><br></pre></td></tr></table></figure>

<p>Java 14 之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">    at NullPointerExample.main(NullPointerExample.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>Java 14 之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 增加参数后提示的异常中很明确的告知了哪里为空导致</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException:</span><br><span class="line">        Cannot read field <span class="string">&#x27;c&#x27;</span> because <span class="string">&#x27;a.b&#x27;</span> is <span class="keyword">null</span>.</span><br><span class="line">    at Prog.main(Prog.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="switch-的增强-转正"><a href="#switch-的增强-转正" class="headerlink" title="switch 的增强(转正)"></a>switch 的增强(转正)</h3><p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。</p>
<p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 <code>yield</code> 来在 block 中返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;M&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;F&quot;</span> -&gt; <span class="string">&quot;MWF&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;T&quot;</span>, <span class="string">&quot;TH&quot;</span>, <span class="string">&quot;S&quot;</span> -&gt; <span class="string">&quot;TTS&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(day.isEmpty())</span><br><span class="line">                    yield <span class="string">&quot;Please insert a valid day.&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    yield <span class="string">&quot;Looks like a Sunday.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h3 id="预览新特性"><a href="#预览新特性" class="headerlink" title="预览新特性"></a>预览新特性</h3><h4 id="record-关键字"><a href="#record-关键字" class="headerlink" title="record 关键字"></a>record 关键字</h4><p><code>record</code> 关键字可以简化 <strong>数据类</strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 <code>record</code> 代替 <code>class</code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 <code>toString()</code>，<code>hashCode()</code>, <code>equals()</code>方法。</p>
<p>类似于使用 <code>class</code> 定义类，同时使用了 lombok 插件，并打上了<code>@Getter,@ToString,@EqualsAndHashCode</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类具有两个特征</span></span><br><span class="line"><span class="comment"> * 1. 所有成员属性都是final</span></span><br><span class="line"><span class="comment"> * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）</span></span><br><span class="line"><span class="comment"> * 那么这种类就很适合使用record来声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 使用record声明的类会自动拥有上面类中的三个方法</span></span><br><span class="line"><span class="comment"> * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法</span></span><br><span class="line"><span class="comment"> * 3. toString方法中包括所有成员属性的字符串表示形式及其名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">float</span> length, <span class="keyword">float</span> width)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>Java14 中，文本块依然是预览特性，不过，其引入了两个新的转义字符：</p>
<ul>
<li><code>\</code> : 表示行尾，不引入换行符</li>
<li><code>\s</code>：表示单个空格</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;凡心所向，素履所往，生如逆旅，一苇以航。&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        凡心所向，素履所往， \</span></span><br><span class="line"><span class="string">        生如逆旅，一苇以航。&quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(str2);<span class="comment">// 凡心所向，素履所往， 生如逆旅，一苇以航。</span></span><br><span class="line">String text = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        java</span></span><br><span class="line"><span class="string">        c++\sphp</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(text);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">java</span><br><span class="line">c++ php</span><br></pre></td></tr></table></figure>

<h4 id="instanceof-增强"><a href="#instanceof-增强" class="headerlink" title="instanceof 增强"></a>instanceof 增强</h4><p>依然是<strong>预览特性</strong> ，<a href="./java12-13.md">Java 12 新特性</a>中介绍过。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Windows（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li>
<li>移除了 CMS(Concurrent Mark Sweep) 垃圾收集器（功成而退）</li>
<li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code>deb</code>和<code>rpm</code>，window 平台下的<code>msi</code>和<code>exe</code></li>
</ul>
<h2 id="Java15"><a href="#Java15" class="headerlink" title="Java15"></a>Java15</h2><h3 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h3><p><code>CharSequence</code> 接口添加了一个默认方法 <code>isEmpty()</code> 来判断字符序列为空，如果是则返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code> 新引入了下面这些方法：</p>
<ul>
<li><code>putIfAbsent()</code></li>
<li><code>computeIfAbsent()</code></li>
<li><code>computeIfPresent()</code></li>
<li><code>compute()</code></li>
<li><code>merge()</code></li>
</ul>
<h3 id="ZGC-转正"><a href="#ZGC-转正" class="headerlink" title="ZGC(转正)"></a>ZGC(转正)</h3><p>Java11 的时候 ，ZGC 还在试验阶段。</p>
<p>当时，ZGC 的出现让众多 Java 开发者看到了垃圾回收器的另外一种可能，因此备受关注。</p>
<p>经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p>
<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC className</span><br></pre></td></tr></table></figure>

<h3 id="EdDSA-数字签名算法"><a href="#EdDSA-数字签名算法" class="headerlink" title="EdDSA(数字签名算法)"></a>EdDSA(数字签名算法)</h3><p>新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。</p>
<p>虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator kpg = KeyPairGenerator.getInstance(<span class="string">&quot;Ed25519&quot;</span>);</span><br><span class="line">KeyPair kp = kpg.generateKeyPair();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] msg = <span class="string">&quot;test_string&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">Signature sig = Signature.getInstance(<span class="string">&quot;Ed25519&quot;</span>);</span><br><span class="line">sig.initSign(kp.getPrivate());</span><br><span class="line">sig.update(msg);</span><br><span class="line"><span class="keyword">byte</span>[] s = sig.sign();</span><br><span class="line"></span><br><span class="line">String encodedString = Base64.getEncoder().encodeToString(s);</span><br><span class="line">System.out.println(encodedString);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0Hc0lxxASZNvS52WsvnncJOH/mlFhnA8Tc6D/k5DtAX5BSsNVjtPF4R4+yMWXVjrvB2mxVXmChIbki6goFBgAg==</span><br></pre></td></tr></table></figure>

<h3 id="文本块-转正"><a href="#文本块-转正" class="headerlink" title="文本块(转正)"></a>文本块(转正)</h3><p>在 Java 15 ，文本块是正式的功能特性了。</p>
<h3 id="隐藏类-Hidden-Classes"><a href="#隐藏类-Hidden-Classes" class="headerlink" title="隐藏类(Hidden Classes)"></a>隐藏类(Hidden Classes)</h3><p>隐藏类是为框架（frameworks）所设计的，隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们。</p>
<h3 id="预览新特性-1"><a href="#预览新特性-1" class="headerlink" title="预览新特性"></a>预览新特性</h3><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p><strong>密封类（Sealed Classes）</strong> 是 Java 15 中的一个预览新特性。</p>
<p>没有密封类之前，在 Java 中如果想让一个类不能被继承和修改，我们可以使用<code>final</code> 关键字对类进行修饰。不过，这种方式不太灵活，直接把一个类的继承和修改渠道给堵死了。</p>
<p>密封类可以对继承或者实现它们的类进行限制，这样这个类就只能被指定的类继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类 Person 只允许 Employee 和 Manager 继承。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">permits</span> <span class="title">Employee</span>, <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，任何扩展密封类的类本身都必须声明为 <code>sealed</code>、<code>non-sealed</code> 或 <code>final</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> non-sealed <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/javaguide/image-20210820153955587.png"></p>
<p>如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。</p>
<h4 id="instanceof-模式匹配"><a href="#instanceof-模式匹配" class="headerlink" title="instanceof 模式匹配"></a>instanceof 模式匹配</h4><p>Java 15 并没有对此特性进行调整，继续预览特性，主要用于接受更多的使用反馈。</p>
<p>在未来的 Java 版本中，Java 的目标是继续完善 <code>instanceof</code> 模式匹配新特性。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul>
<li><strong>Nashorn JavaScript 引擎彻底移除</strong>：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性。在 Java 11 中就已经被弃用，到了 Java 15 就彻底被删除了。</li>
<li><strong>DatagramSocket API 重构</strong></li>
<li><strong>禁用和废弃偏向锁（Biased Locking）</strong>：偏向锁的引入增加了 JVM 的复杂性大于其带来的性能提升。不过，你仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁定，但它会提示这是一个已弃用的 API。</li>
<li>……</li>
</ul>
<h1 id="Java12-新特性"><a href="#Java12-新特性" class="headerlink" title="Java12 新特性"></a>Java12 新特性</h1><h3 id="String-增强"><a href="#String-增强" class="headerlink" title="String 增强"></a>String 增强</h3><p>Java 12 增加了两个的字符串处理方法，如以下所示。</p>
<p><code>indent()</code> 方法可以实现字符串缩进。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 缩进 4 格</span></span><br><span class="line">text = text.indent(<span class="number">4</span>);</span><br><span class="line">System.out.println(text);</span><br><span class="line">text = text.indent(-<span class="number">10</span>);</span><br><span class="line">System.out.println(text);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     Java</span><br><span class="line">Java</span><br></pre></td></tr></table></figure>

<p><code>transform()</code> 方法可以用来转变指定字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">&quot;foo&quot;</span>.transform(input -&gt; input + <span class="string">&quot; bar&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// foo bar</span></span><br></pre></td></tr></table></figure>

<h3 id="Files-增强（文件比较）"><a href="#Files-增强（文件比较）" class="headerlink" title="Files 增强（文件比较）"></a>Files 增强（文件比较）</h3><p>Java 12 添加了以下方法来比较两个文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mismatch</span><span class="params">(Path path, Path path2)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p><code>mismatch()</code> 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L。</p>
<p>代码示例（两个文件内容相同的情况）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path filePath1 = Files.createTempFile(<span class="string">&quot;file1&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">Path filePath2 = Files.createTempFile(<span class="string">&quot;file2&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">Files.writeString(filePath1, <span class="string">&quot;Java 12 Article&quot;</span>);</span><br><span class="line">Files.writeString(filePath2, <span class="string">&quot;Java 12 Article&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> mismatch = Files.mismatch(filePath1, filePath2);</span><br><span class="line">assertEquals(-<span class="number">1</span>, mismatch);</span><br></pre></td></tr></table></figure>

<p>代码示例（两个文件内容不相同的情况）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path filePath3 = Files.createTempFile(<span class="string">&quot;file3&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">Path filePath4 = Files.createTempFile(<span class="string">&quot;file4&quot;</span>, <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">Files.writeString(filePath3, <span class="string">&quot;Java 12 Article&quot;</span>);</span><br><span class="line">Files.writeString(filePath4, <span class="string">&quot;Java 12 Tutorial&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> mismatch = Files.mismatch(filePath3, filePath4);</span><br><span class="line">assertEquals(<span class="number">8</span>, mismatch);</span><br></pre></td></tr></table></figure>

<h3 id="数字格式化工具类"><a href="#数字格式化工具类" class="headerlink" title="数字格式化工具类"></a>数字格式化工具类</h3><p><code>NumberFormat</code> 新增了对复杂的数字进行格式化的支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);</span><br><span class="line">String result = fmt.format(<span class="number">1000</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1K</span><br></pre></td></tr></table></figure>

<h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p>Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等</p>
<p>和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性。</p>
<h3 id="G1-收集器优化"><a href="#G1-收集器优化" class="headerlink" title="G1 收集器优化"></a>G1 收集器优化</h3><p>Java12 为默认的垃圾收集器 G1 带来了两项更新:</p>
<ul>
<li><strong>可中止的混合收集集合</strong>：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标</li>
<li><strong>及时返回未使用的已分配内存</strong>：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统</li>
</ul>
<h3 id="预览新特性-2"><a href="#预览新特性-2" class="headerlink" title="预览新特性"></a>预览新特性</h3><p>作为预览特性加入，需要在<code>javac</code>编译和<code>java</code>运行时增加参数<code>--enable-preview</code> 。</p>
<h4 id="增强-Switch"><a href="#增强-Switch" class="headerlink" title="增强 Switch"></a>增强 Switch</h4><p>传统的 <code>switch</code> 语法存在容易漏写 <code>break</code> 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复。</p>
<p>Java12 增强了 <code>switch</code> 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="instanceof-模式匹配-1"><a href="#instanceof-模式匹配-1" class="headerlink" title="instanceof 模式匹配"></a>instanceof 模式匹配</h4><p><code>instanceof</code> 主要在类型强转前探测对象的具体类型。</p>
<p>之前的版本中，我们需要显示地对对象进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="string">&quot;我是字符串&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">   String str = (String) obj;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版的 <code>instanceof</code> 可以在判断是否属于具体的类型同时完成转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="string">&quot;我是字符串&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java13-新特性"><a href="#Java13-新特性" class="headerlink" title="Java13 新特性"></a>Java13 新特性</h1><h3 id="增强-ZGC-释放未使用内存"><a href="#增强-ZGC-释放未使用内存" class="headerlink" title="增强 ZGC(释放未使用内存)"></a>增强 ZGC(释放未使用内存)</h3><p>在 Java 11 中实验性引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题。</p>
<p>ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 <strong>ZPageCache</strong> 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织。</p>
<p>在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用。</p>
<h3 id="SocketAPI-重构"><a href="#SocketAPI-重构" class="headerlink" title="SocketAPI 重构"></a>SocketAPI 重构</h3><p>Java Socket API 终于迎来了重大更新！</p>
<p>Java 13 将 Socket API 的底层进行了重写， <code>NioSocketImpl</code> 是对 <code>PlainSocketImpl</code> 的直接替代，它使用 <code>java.util.concurrent</code> 包下的锁而不是同步方法。如果要使用旧实现，请使用 <code>-Djdk.net.usePlainSocketImpl=true</code>。</p>
<p>并且，在 Java 13 中是默认使用新的 Socket 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketImpl</span> <span class="keyword">extends</span> <span class="title">SocketImpl</span> <span class="keyword">implements</span> <span class="title">PlatformSocketImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileSystems"><a href="#FileSystems" class="headerlink" title="FileSystems"></a>FileSystems</h3><p><code>FileSystems</code> 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：</p>
<ul>
<li><code>newFileSystem(Path)</code></li>
<li><code>newFileSystem(Path, Map&lt;String, ?&gt;)</code></li>
<li><code>newFileSystem(Path, Map&lt;String, ?&gt;, ClassLoader)</code></li>
</ul>
<h3 id="动态-CDS-存档"><a href="#动态-CDS-存档" class="headerlink" title="动态 CDS 存档"></a>动态 CDS 存档</h3><p>Java 13 中对 Java 10 中引入的应用程序类数据共享(AppCDS)进行了进一步的简化、改进和扩展，即：<strong>允许在 Java 应用程序执行结束时动态进行类归档</strong>，具体能够被归档的类包括所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类。</p>
<p>这提高了应用程序类数据共享（<a href="https://openjdk.java.net/jeps/310">AppCDS</a>）的可用性。无需用户进行试运行来为每个应用程序创建类列表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:ArchiveClassesAtExit=my_app_cds.jsa -cp my_app.jar</span><br><span class="line">java -XX:SharedArchiveFile=my_app_cds.jsa -cp my_app.jar</span><br></pre></td></tr></table></figure>

<h3 id="预览新特性-3"><a href="#预览新特性-3" class="headerlink" title="预览新特性"></a>预览新特性</h3><h4 id="文本块-1"><a href="#文本块-1" class="headerlink" title="文本块"></a>文本块</h4><p>解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入<strong>三重双引号</strong>来定义多行文本。</p>
<p>Java 13 支持两个 <code>&quot;&quot;&quot;</code> 符号中间的任何内容都会被解释为字符串的一部分，包括换行符。</p>
<p>未支持文本块之前的 HTML 写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json =<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;   \&quot;name\&quot;:\&quot;mkyong\&quot;,\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;   \&quot;age\&quot;:38\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&#125;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>支持文本块之后的 HTML 写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">               &#123;</span></span><br><span class="line"><span class="string">                   &quot;</span>name<span class="string">&quot;:&quot;</span>mkyong<span class="string">&quot;,</span></span><br><span class="line"><span class="string">                   &quot;</span>age<span class="string">&quot;:38</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>未支持文本块之前的 SQL 写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n&quot; <span class="operator">+</span></span><br><span class="line">               &quot;WHERE `CITY` = &#x27;INDIANAPOLIS&#x27;\n&quot; <span class="operator">+</span></span><br><span class="line">               &quot;ORDER BY `EMP_ID`, `LAST_NAME`;\n&quot;;</span><br></pre></td></tr></table></figure>

<p>支持文本块之后的 SQL 写法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String query <span class="operator">=</span> &quot;&quot;&quot;</span><br><span class="line">               SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`</span><br><span class="line">               WHERE `CITY` = &#x27;INDIANAPOLIS&#x27;</span><br><span class="line">               ORDER BY `EMP_ID`, `LAST_NAME`;</span><br><span class="line">               &quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>另外，<code>String</code> 类新增加了 3 个新的方法来操作文本块：</p>
<ul>
<li><code>formatted(Object... args)</code>：它类似于 <code>String</code> 的<code>format()</code>方法。添加它是为了支持文本块的格式设置。</li>
<li><code>stripIndent()</code>：用于去除文本块中每一行开头和结尾的空格。</li>
<li><code>translateEscapes()</code>：转义序列如 <em>“\\t”</em> 转换为 <em>“\t”</em></li>
</ul>
<p>由于文本块是一项预览功能，可以在未来版本中删除，因此这些新方法被标记为弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated(forRemoval=true, since=&quot;13&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stripIndent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated(forRemoval=true, since=&quot;13&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">formatted</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated(forRemoval=true, since=&quot;13&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translateEscapes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增强-Switch-引入-yield-关键字到-Switch-中"><a href="#增强-Switch-引入-yield-关键字到-Switch-中" class="headerlink" title="增强 Switch(引入 yield 关键字到 Switch 中)"></a>增强 Switch(引入 yield 关键字到 Switch 中)</h4><p><code>Switch</code> 表达式中就多了一个关键字用于跳出 <code>Switch</code> 块的关键字 <code>yield</code>，主要用于返回一个值</p>
<p><code>yield</code>和 <code>return</code> 的区别在于：<code>return</code> 会直接跳出当前循环或者方法，而 <code>yield</code> 只会跳出当前 <code>Switch</code> 块，同时在使用 <code>yield</code> 时，需要有 <code>default</code> 条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">descLanguage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Java&quot;</span>: yield <span class="string">&quot;object-oriented, platform independent and secured&quot;</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Ruby&quot;</span>: yield <span class="string">&quot;a programmer&#x27;s best friend&quot;</span>;</span><br><span class="line">           <span class="keyword">default</span>: yield name +<span class="string">&quot; is a good language&quot;</span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于预览特性"><a href="#关于预览特性" class="headerlink" title="关于预览特性"></a>关于预览特性</h3><p>先贴一段 oracle 官网原文：<code>This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.</code></p>
<p>这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。</p>
<p>就以<code>switch</code>的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改</p>
<p>一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证</p>
<h3 id="JVM-虚拟机优化"><a href="#JVM-虚拟机优化" class="headerlink" title="JVM 虚拟机优化"></a>JVM 虚拟机优化</h3><p>每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等</p>
<p>整体优化的方向是<strong>高效，低时延的垃圾回收表现</strong></p>
<p>对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是<strong>JVM 运行时的提升</strong></p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ul>
<li>JDK Project Overview：<a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/</a></li>
<li>Oracle Java12 ReleaseNote：<a href="https://www.oracle.com/java/technologies/javase/12all-relnotes.htm">https://www.oracle.com/java/technologies/javase/12all-relnotes.htm</a></li>
<li>What is new in Java 12：<a href="https://mkyong.com/java/what-is-new-in-java-12/">https://mkyong.com/java/what-is-new-in-java-12/</a></li>
<li>Oracle Java13 ReleaseNote <a href="https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature">https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature</a></li>
<li>New Java13 Features <a href="https://www.baeldung.com/java-13-new-features">https://www.baeldung.com/java-13-new-features</a></li>
<li>Java13 新特性概述 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html</a><h1 id="Java11-新特性"><a href="#Java11-新特性" class="headerlink" title="Java11 新特性"></a>Java11 新特性</h1></li>
</ul>
<p><strong>Java 11</strong> 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，<strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。</strong></p>
<p><strong>概览（精选了一部分）</strong>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/321">JEP 321：HTTP Client 标准化</a></li>
<li><a href="https://openjdk.java.net/jeps/333">JEP 333：ZGC(可伸缩低延迟垃圾收集器)</a></li>
<li><a href="https://openjdk.java.net/jeps/323">JEP 323：Lambda 参数的局部变量语法</a></li>
<li><a href="https://openjdk.java.net/jeps/330">JEP 330：启动单文件源代码程序</a></li>
</ul>
<h2 id="HTTP-Client-标准化"><a href="#HTTP-Client-标准化" class="headerlink" title="HTTP Client 标准化"></a>HTTP Client 标准化</h2><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。</p>
<p>并且，Java 11 中，Http Client 的包名由 <code>jdk.incubator.http</code> 改为<code>java.net.http</code>，该 API 通过 <code>CompleteableFuture</code> 提供非阻塞请求和响应语义。使用起来也很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">&quot;https://javastack.cn&quot;</span>))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="String-增强-1"><a href="#String-增强-1" class="headerlink" title="String 增强"></a>String 增强</h2><p>Java 11 增加了一系列的字符串处理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h2 id="Optional-增强"><a href="#Optional-增强" class="headerlink" title="Optional 增强"></a>Optional 增强</h2><p>新增了<code>isEmpty()</code>方法来判断指定的 <code>Optional</code> 对象是否为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> op = Optional.empty();</span><br><span class="line">System.out.println(op.isEmpty());<span class="comment">//判断指定的 Optional 对象是否为空</span></span><br></pre></td></tr></table></figure>

<h2 id="ZGC-可伸缩低延迟垃圾收集器"><a href="#ZGC-可伸缩低延迟垃圾收集器" class="headerlink" title="ZGC(可伸缩低延迟垃圾收集器)"></a>ZGC(可伸缩低延迟垃圾收集器)</h2><p><strong>ZGC 即 Z Garbage Collector</strong>，是一个可伸缩的、低延迟的垃圾收集器。</p>
<p>ZGC 主要为了满足如下目标进行设计：</p>
<ul>
<li>GC 停顿时间不超过 10ms</li>
<li>即能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li>
<li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li>
<li>方便在此基础上引入新的 GC 特性和利用 colored 针以及 Load barriers 优化奠定基础</li>
<li>当前只支持 Linux/x64 位平台</li>
</ul>
<p>ZGC 目前 <strong>处在实验阶段</strong>，只支持 Linux/x64 平台。</p>
<p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<p>详情可以看：<a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》</a></p>
<h2 id="Lambda-参数的局部变量语法"><a href="#Lambda-参数的局部变量语法" class="headerlink" title="Lambda 参数的局部变量语法"></a>Lambda 参数的局部变量语法</h2><p>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。</p>
<p>Java 10 中对 var 关键字存在几个限制</p>
<ul>
<li>只能用于局部变量上</li>
<li>声明时必须初始化</li>
<li>不能用作方法参数</li>
<li>不能在 Lambda 表达式中使用</li>
</ul>
<p>Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两者是等价的</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> i) -&gt; System.out.println(i);</span><br><span class="line">Consumer&lt;String&gt; consumer = (String i) -&gt; System.out.println(i);</span><br></pre></td></tr></table></figure>

<h2 id="启动单文件源代码程序"><a href="#启动单文件源代码程序" class="headerlink" title="启动单文件源代码程序"></a>启动单文件源代码程序</h2><p>这意味着我们可以运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行，不需要在磁盘上生成 <code>.class</code> 文件了。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。</p>
<p>对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用。一定能程度上增强了使用 Java 来写脚本程序的能力。</p>
<h2 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h2><ul>
<li><strong>新的垃圾回收器 Epsilon</strong>：一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间</li>
<li><strong>低开销的 Heap Profiling</strong>：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息</li>
<li><strong>TLS1.3 协议</strong>：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升</li>
<li>**飞行记录器(Java Flight Recorder)**：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了。</li>
<li>……</li>
<li><h1 id="Java10-新特性"><a href="#Java10-新特性" class="headerlink" title="Java10 新特性"></a>Java10 新特性</h1></li>
</ul>
<p><strong>Java 10</strong> 发布于 2018 年 3 月 20 日，最知名的特性应该是 <code>var</code> 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。</p>
<p><strong>概览（精选了一部分）</strong>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/286">JEP 286：局部变量类型推断</a></li>
<li><a href="https://openjdk.java.net/jeps/304">JEP 304：垃圾回收器接口</a></li>
<li><a href="https://openjdk.java.net/jeps/307">JEP 307：G1 并行 Full GC</a></li>
<li><a href="https://openjdk.java.net/jeps/310">JEP 310：应用程序类数据共享(扩展 CDS 功能)</a></li>
<li><a href="https://openjdk.java.net/jeps/317">JEP 317：实验性的基于 Java 的 JIT 编译器</a></li>
</ul>
<h2 id="局部变量类型推断-var"><a href="#局部变量类型推断-var" class="headerlink" title="局部变量类型推断(var)"></a>局部变量类型推断(var)</h2><p>由于太多 Java 开发者希望 Java 中引入局部变量推断，于是 Java 10 的时候它来了，也算是众望所归了！</p>
<p>Java 10 提供了 <code>var</code> 关键字声明局部变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> codefx = <span class="keyword">new</span> URL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">var</span> p = Paths.of(<span class="string">&quot;src/test/java/Java9FeaturesTest.java&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numbers = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n : list)</span><br><span class="line">    System.out.print(n+ <span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>var 关键字只能用于带有构造器的局部变量和 for 循环中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count=<span class="keyword">null</span>; <span class="comment">//❌编译不通过，不能声明为 null</span></span><br><span class="line"><span class="keyword">var</span> r = () -&gt; Math.random();<span class="comment">//❌编译不通过,不能声明为 Lambda表达式</span></span><br><span class="line"><span class="keyword">var</span> array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//❌编译不通过,不能声明数组</span></span><br></pre></td></tr></table></figure>

<p>var 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。</p>
<p>另外，Scala 和 Kotlin 中已经有了 <code>val</code> 关键字 ( <code>final var</code> 组合关键字)。</p>
<p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/34911982">《Java 10 新特性之局部变量类型推断》</a>。</p>
<h2 id="垃圾回收器接口"><a href="#垃圾回收器接口" class="headerlink" title="垃圾回收器接口"></a>垃圾回收器接口</h2><p>在早期的 JDK 结构中，组成垃圾收集器 (GC) 实现的组件分散在代码库的各个部分。 Java 10 通过引入一套纯净的垃圾收集器接口来将不同垃圾收集器的源代码分隔开。</p>
<h2 id="G1-并行-Full-GC"><a href="#G1-并行-Full-GC" class="headerlink" title="G1 并行 Full GC"></a>G1 并行 Full GC</h2><p>从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。</p>
<p>为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p>
<h2 id="集合增强"><a href="#集合增强" class="headerlink" title="集合增强"></a>集合增强</h2><p><code>List</code>，<code>Set</code>，<code>Map</code> 提供了静态方法<code>copyOf()</code>返回入参集合的一个不可变拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>copyOf()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。 IDEA 也会有相应的提示。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210816154125579.png"></p>
<p>并且，<code>java.util.stream.Collectors</code> 中新增了静态方法，用于将流中的元素收集为不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.stream().collect(Collectors.toUnmodifiableList());</span><br><span class="line">list.stream().collect(Collectors.toUnmodifiableSet());</span><br></pre></td></tr></table></figure>

<h2 id="Optional-增强-1"><a href="#Optional-增强-1" class="headerlink" title="Optional 增强"></a>Optional 增强</h2><p><code>Optional</code> 新增了<code>orElseThrow()</code>方法来在没有值时抛出指定的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(cache.getIfPresent(key))</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> PrestoException(NOT_FOUND, <span class="string">&quot;Missing entry found for key: &quot;</span> + key));</span><br></pre></td></tr></table></figure>

<h2 id="应用程序类数据共享-扩展-CDS-功能"><a href="#应用程序类数据共享-扩展-CDS-功能" class="headerlink" title="应用程序类数据共享(扩展 CDS 功能)"></a>应用程序类数据共享(扩展 CDS 功能)</h2><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。CDS 在当时还是 Oracle JDK 的商业特性。</p>
<p>Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS 为 (Application Class-Data Sharing，AppCDS) 支持，大大加大了 CDS 的适用范围。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。</p>
<h2 id="实验性的基于-Java-的-JIT-编译器"><a href="#实验性的基于-Java-的-JIT-编译器" class="headerlink" title="实验性的基于 Java 的 JIT 编译器"></a>实验性的基于 Java 的 JIT 编译器</h2><p>Graal 是一个基于 Java 语言编写的 JIT 编译器，是 JDK 9 中引入的实验性 Ahead-of-Time (AOT) 编译器的基础。</p>
<p>Oracle 的 HotSpot VM 便附带两个用 C++ 实现的 JIT compiler：C1 及 C2。在 Java 10 (Linux/x64, macOS/x64) 中，默认情况下 HotSpot 仍使用 C2，但通过向 java 命令添加 <code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code> 参数便可将 C2 替换成 Graal。</p>
<p>相关阅读：<a href="https://www.infoq.cn/article/java-10-jit-compiler-graal">深入浅出 Java 10 的实验性 JIT 编译器 Graal - 郑雨迪</a></p>
<h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><ul>
<li><strong>线程-局部管控</strong>：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程</li>
<li><strong>备用存储装置上的堆分配</strong>：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配</li>
<li>……</li>
<li><h1 id="Java9-新特性"><a href="#Java9-新特性" class="headerlink" title="Java9 新特性"></a>Java9 新特性</h1></li>
</ul>
<p><strong>Java 9</strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、<code>Stream</code> 流……。</p>
<p>你可以在 <a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases</a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：<a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/</a> 。</p>
<p><strong>概览（精选了一部分）</strong>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具</a></li>
<li><a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统</a></li>
<li><a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器</a></li>
<li><a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄</a></li>
<li><a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化</a></li>
</ul>
<h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2><p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p>
<p>在 JShell 中可以直接输入表达式并查看其执行结果。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210816083417616.png"></p>
<p><strong>JShell 为我们带来了哪些好处呢？</strong></p>
<ol>
<li>降低了输出第一行 Java 版”Hello World！”的门槛，能够提高新手的学习热情。</li>
<li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。</li>
<li>……</li>
</ol>
<p><strong>JShell 的代码和普通的可编译代码，有什么不一样？</strong></p>
<ol>
<li>一旦语句输入完成，JShell 立即就能返回执行的结果，而不再需要编辑器、编译器、解释器。</li>
<li>JShell 支持变量的重复声明，后面声明的会覆盖前面声明的。</li>
<li>JShell 支持独立的表达式比如普通的加法运算 <code>1 + 1</code>。</li>
<li>……</li>
</ol>
<h2 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h2><p>模块系统是<a href="https://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a>的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！</p>
<p><strong>什么是模块系统？</strong> 官方的定义是：</p>
<blockquote>
<p>A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor。</p>
</blockquote>
<p>简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（<code>module-info.java</code>）。</p>
<p>任意一个 jar 文件，只要加上一个模块描述文件（<code>module-info.java</code>），就可以升级为一个模块。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/module-structure.png"></p>
<p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 <strong><a href="http://openjdk.java.net/jeps/282">jlink</a> 工具</strong> (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p>
<p>我们可以通过 <code>exports</code> 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="comment">//exports 公开指定包的所有公共成员</span></span><br><span class="line">    <span class="keyword">exports</span> com.my.<span class="keyword">package</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">     <span class="comment">//exports…to 限制访问的成员范围</span></span><br><span class="line">    export com.my.<span class="keyword">package</span>.name to com.specific.<span class="keyword">package</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要深入了解 Java 9 的模块化，可以参考下面这几篇文章：</p>
<ul>
<li><a href="https://openjdk.java.net/projects/jigsaw/quick-start">《Project Jigsaw: Module System Quick-Start Guide》</a></li>
<li><a href="https://stacktraceguru.com/java9/module-introduction">《Java 9 Modules: part 1》</a></li>
<li><a href="http://www.cnblogs.com/IcanFixIt/p/6947763.html">Java 9 揭秘（2. 模块化系统）</a></li>
</ul>
<h2 id="G1-成为默认垃圾回收器"><a href="#G1-成为默认垃圾回收器" class="headerlink" title="G1 成为默认垃圾回收器"></a>G1 成为默认垃圾回收器</h2><p>在 Java 8 的时候，默认垃圾回收器是 Parallel Scavenge（新生代）+Parallel Old（老年代）。到了 Java 9, CMS 垃圾回收器被废弃了，<strong>G1（Garbage-First Garbage Collector）</strong> 成为了默认垃圾回收器。</p>
<p>G1 还是在 Java 7 中被引入的，经过两个版本优异的表现成为成为默认垃圾回收器。</p>
<h2 id="快速创建不可变集合"><a href="#快速创建不可变集合" class="headerlink" title="快速创建不可变集合"></a>快速创建不可变集合</h2><p>增加了<code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合（有点参考 Guava 的味道）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Set.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Map.of(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>of()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>
<h2 id="String-存储结构优化"><a href="#String-存储结构优化" class="headerlink" title="String 存储结构优化"></a>String 存储结构优化</h2><p>Java 8 及之前的版本，<code>String</code> 一直是用 <code>char[]</code> 存储。在 Java 9 之后，<code>String</code> 的实现改用 <code>byte[]</code> 数组存储字符串，节省了空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口私有方法"><a href="#接口私有方法" class="headerlink" title="接口私有方法"></a>接口私有方法</h2><p>Java 9 允许在接口中使用私有方法。这样的话，接口的使用就更加灵活了，有点像是一个简化版的抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources-增强"><a href="#try-with-resources-增强" class="headerlink" title="try-with-resources 增强"></a>try-with-resources 增强</h2><p>在 Java 9 之前，我们只能在 <code>try-with-resources</code> 块中声明变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line">    PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(<span class="string">&quot;testWrite.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，在 <code>try-with-resources</code> 语句中可以使用 effectively-final 变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> File(<span class="string">&quot;testWrite.txt&quot;</span>))</span><br><span class="line"><span class="keyword">try</span> (scanner;writer) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是 effectively-final 变量？</strong> 简单来说就是没有被 <code>final</code> 修饰但是值在初始化后从未更改的变量。</p>
<p>正如上面的代码所演示的那样，即使 <code>writer</code> 变量没有被显示声明为 <code>final</code>，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。</p>
<h2 id="Stream-amp-Optional-增强"><a href="#Stream-amp-Optional-增强" class="headerlink" title="Stream &amp; Optional 增强"></a>Stream &amp; Optional 增强</h2><p><code>Stream</code> 中增加了新的方法 <code>ofNullable()</code>、<code>dropWhile()</code>、<code>takeWhile()</code> 以及 <code>iterate()</code> 方法的重载方法。</p>
<p>Java 9 中的 <code>ofNullable()</code> 方 法允许我们创建一个单元素的 <code>Stream</code>，可以包含一个非空元素，也可以创建一个空 <code>Stream</code>。 而在 Java 8 中则不可以创建空的 <code>Stream</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">// 1</span></span><br><span class="line">Stream&lt;String&gt; nullStream = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(nullStream.count());<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p><code>takeWhile()</code> 方法可以从 <code>Stream</code> 中依次获取满足条件的元素，直到不满足条件为止结束获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 11 33</span></span><br></pre></td></tr></table></figure>

<p><code>dropWhile()</code> 方法的效果和 <code>takeWhile()</code> 相反。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList2 = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList2.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 66 8 9 13</span></span><br></pre></td></tr></table></figure>

<p><code>iterate()</code> 方法的新重载方法提供了一个 <code>Predicate</code> 参数 (判断条件)来决定什么时候结束迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增加的重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="keyword">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的使用对比如下，新的 <code>iterate()</code> 重载方法更加灵活一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用原始 iterate() 方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 使用新的 iterate() 重载方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><code>Optional</code> 类中新增了 <code>ifPresentOrElse()</code>、<code>or()</code> 和 <code>stream()</code> 等方法</p>
<p><code>ifPresentOrElse()</code> 方法接受两个参数 <code>Consumer</code> 和 <code>Runnable</code> ，如果 <code>Optional</code> 不为空调用 <code>Consumer</code> 参数，为空则调用 <code>Runnable</code> 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Runnable emptyAction)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Optional&lt;Object&gt; objectOptional </span>= Optional.empty();</span><br><span class="line">objectOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">&quot;Empty!!!&quot;</span>));<span class="comment">// Empty!!!</span></span><br></pre></td></tr></table></figure>

<p><code>or()</code> 方法接受一个 <code>Supplier</code> 参数 ，如果 <code>Optional</code> 为空则返回 <code>Supplier</code> 参数指定的 <code>Optional</code> 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">or</span><span class="params">(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Optional&lt;Object&gt; objectOptional </span>= Optional.empty();</span><br><span class="line">objectOptional.or(() -&gt; Optional.of(<span class="string">&quot;java&quot;</span>)).ifPresent(System.out::println);<span class="comment">//java</span></span><br></pre></td></tr></table></figure>

<h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>Java 9 增加了 <code>java.lang.ProcessHandle</code> 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前正在运行的 JVM 的进程</span></span><br><span class="line">ProcessHandle currentProcess = ProcessHandle.current();</span><br><span class="line"><span class="comment">// 输出进程的 id</span></span><br><span class="line">System.out.println(currentProcess.pid());</span><br><span class="line"><span class="comment">// 输出进程的信息</span></span><br><span class="line">System.out.println(currentProcess.info());</span><br></pre></td></tr></table></figure>

<p><code>ProcessHandle</code> 接口概览：</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210816104614414.png"></p>
<h2 id="响应式流-（-Reactive-Streams-）"><a href="#响应式流-（-Reactive-Streams-）" class="headerlink" title="响应式流 （ Reactive Streams ）"></a>响应式流 （ Reactive Streams ）</h2><p>在 Java 9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口 。</p>
<p><code>Flow</code> 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code> 和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</p>
<p>关于 Java 9 响应式流更详细的解读，推荐你看 <a href="https://www.cnblogs.com/IcanFixIt/p/7245377.html">Java 9 揭秘（17. Reactive Streams ）- 林本托</a> 这篇文章。</p>
<h2 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h2><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。</p>
<p>变量句柄的含义类似于已有的方法句柄 <code>MethodHandle</code> ，由 Java 类 <code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对象。</p>
<p><code>VarHandle</code> 的出现替代了 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><strong>平台日志 API 改进</strong>：Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</li>
<li><strong><code>CompletableFuture</code>类增强</strong>：新增了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）。</li>
<li><strong>Nashorn 引擎的增强</strong>：Nashorn 是从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。</li>
<li><strong>I/O 流的新特性</strong>：增加了新的方法来读取和复制 <code>InputStream</code> 中包含的数据。</li>
<li><strong>改进应用的安全性能</strong>：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512。</li>
<li><strong>改进方法句柄（Method Handle）</strong>：方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄。</li>
<li>……</li>
</ul>
<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。</p>
<p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p>
<p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>
<p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p>
<ol>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li>
</ol>
<p>我们来看一个实际的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">def</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">def2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceNew1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">def</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceNew1 default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceNewImpl</span> <span class="keyword">implements</span> <span class="title">InterfaceNew</span> , <span class="title">InterfaceNew1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterfaceNewImpl interfaceNew = <span class="keyword">new</span> InterfaceNewImpl();</span><br><span class="line">        interfaceNew.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">def</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InterfaceNew1.<span class="keyword">super</span>.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p>
<p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p>
<p>其实它们还是有区别的</p>
<ol>
<li><p>interface 和 class 的区别，好像是废话，主要有：</p>
<ul>
<li>接口多实现，类单继承</li>
<li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
</ul>
</li>
<li><p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p>
</li>
</ol>
<p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>
<p><strong>记住接口永远和类不一样。</strong></p>
<h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p>
<p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p>
<p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有</p>
<p><code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p>
<blockquote>
<p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p>
</blockquote>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-实战"><a href="#Lambda-实战" class="headerlink" title="Lambda 实战"></a>Lambda 实战</h3><p>我们用常用的实例来感受 Lambda 带来的便利</p>
<h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p>
<p><strong>1.<code>Runnable</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br></pre></td></tr></table></figure>

<p><strong>2.<code>Comparator</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br></pre></td></tr></table></figure>

<p><strong>3.<code>Listener</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JButton button = <span class="keyword">new</span> JButton();</span><br><span class="line">button.addItemListener(<span class="keyword">new</span> ItemListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemStateChanged</span><span class="params">(ItemEvent e)</span> </span>&#123;</span><br><span class="line">   e.getItem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">button.addItemListener(e -&gt; e.getItem());</span><br></pre></td></tr></table></figure>

<p><strong>4.自定义接口</strong></p>
<p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们自定义一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LambdaInterface</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lambdaInterfaceDemo(()-&gt; System.out.println(<span class="string">&quot;自定义函数式接口&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数式接口参数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambdaInterfaceDemo</span><span class="params">(LambdaInterface i)</span></span>&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lamndaFor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//传统foreach</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Lambda foreach</span></span><br><span class="line">        strings.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">     <span class="comment">//map</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;System.out.println(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaClassSuper</span> </span>&#123;</span><br><span class="line">    <span class="function">LambdaInterface <span class="title">sf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaClass</span> <span class="keyword">extends</span> <span class="title">LambdaClassSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title">staticF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LambdaInterface <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        LambdaInterface t = LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        LambdaClass lambdaClass = <span class="keyword">new</span> LambdaClass();</span><br><span class="line">        LambdaInterface lambdaInterface = lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        LambdaInterface superf = <span class="keyword">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        LambdaInterface tt = LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line"><span class="comment">//i =3;</span></span><br></pre></td></tr></table></figure>

<p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol>
<li>stream 串行流</li>
<li>parallelStream 并行流，可多线程执行</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">* 返回一个并行流</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">* 返回T的流</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">* 返回其元素是指定值的顺序流。</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function">* 此流任意元素是否有与提供的predicate匹配。</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个 Stream的构建器。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Builder&lt;T&gt; <span class="title">builder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="keyword">long</span> count = stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics statistics = number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    Stream stream = strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p>
<p>我们下面分解一下 <code>filter</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">laziness</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  Stream&lt;Integer&gt; stream = strings.stream().filter(<span class="keyword">new</span> Predicate() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate.test 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;count 执行&quot;</span>);</span><br><span class="line">   stream.count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------执行结果--------*/</span></span><br><span class="line">count 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br></pre></td></tr></table></figure>

<p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p>
<p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parallelStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&quot;</span>+num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">main&gt;&gt;<span class="number">5</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>&gt;&gt;<span class="number">4</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">11</span>&gt;&gt;<span class="number">1</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">9</span>&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从结果中我们看到，for-each 用到的是多线程。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从源码和实例中我们可以总结出一些 stream 的特点</p>
<ol>
<li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li>
<li>方法参数都是函数式接口类型</li>
<li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li>
<li>Stream 不保存数据，不改变数据源</li>
</ol>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>在<a href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p>
<blockquote>
<p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p>
<p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p>
<p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p>
<p>2） 数据库的查询结果可能为 null。</p>
<p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p>
<p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p>
<p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p>
<p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p>
<p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p>
</blockquote>
<p>他建议使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p>
<p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传统解决 NPE 的办法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Zoo zoo = getZoo();</span><br><span class="line"><span class="keyword">if</span>(zoo != <span class="keyword">null</span>)&#123;</span><br><span class="line">   Dog dog = zoo.getDog();</span><br><span class="line">   <span class="keyword">if</span>(dog != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> age = dog.getAge();</span><br><span class="line">      System.out.println(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p>
<p><code>Optional</code> 是这样的实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>是不是简洁了很多呢？</p>
<h3 id="如何创建一个-Optional"><a href="#如何创建一个-Optional" class="headerlink" title="如何创建一个 Optional"></a>如何创建一个 Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Common instance for &#123;<span class="doctag">@code</span> empty()&#125;. 全局EMPTY对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value是null就返回EMPTY，否则就返回of(T)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 EMPTY 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Optional对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私有构造方法，给value赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p>
<p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p>
<p><code>map</code> 和 <code>flatMap</code> 都是将一个函数应用于集合中的每个元素，但不同的是<code>map</code>返回一个新的集合，<code>flatMap</code>是将每个元素都映射为一个集合，最后再将这个集合展平。</p>
<p>在实际应用场景中，如果<code>map</code>返回的是数组，那么最后得到的是一个二维数组，使用<code>flatMap</code>就是为了将这个二维数组展平变成一个一维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapAndFlatMapExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String[]&gt; listOfArrays = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;melon&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String[]&gt; mapResult = listOfArrays.stream()</span><br><span class="line">                .map(array -&gt; Arrays.stream(array).map(String::toUpperCase).toArray(String[]::<span class="keyword">new</span>))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using map:&quot;</span>);</span><br><span class="line">        System.out.println(mapResult);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; flatMapResult = listOfArrays.stream()</span><br><span class="line">                .flatMap(array -&gt; Arrays.stream(array).map(String::toUpperCase))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using flatMap:&quot;</span>);</span><br><span class="line">        System.out.println(flatMapResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using map:</span><br><span class="line">[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]</span><br><span class="line"></span><br><span class="line">Using flatMap:</span><br><span class="line">[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]</span><br></pre></td></tr></table></figure>

<p>最简单的理解就是<code>flatMap()</code>可以将<code>map()</code>的结果展开。</p>
<p>在<code>Optional</code>里面，当使用<code>map()</code>时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的<code>Optional</code>中。而使用<code>flatMap</code>时，如果映射函数返回的是一个<code>Optional</code>，它会将这个返回的<code>Optional</code>展平，不再包装成嵌套的<code>Optional</code>。</p>
<p>下面是一个对比的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> userId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用flatMap的代码</span></span><br><span class="line">        String cityUsingFlatMap = getUserById(userId)</span><br><span class="line">                .flatMap(OptionalExample::getAddressByUser)</span><br><span class="line">                .map(Address::getCity)</span><br><span class="line">                .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city using flatMap: &quot;</span> + cityUsingFlatMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用flatMap的代码</span></span><br><span class="line">        Optional&lt;Optional&lt;Address&gt;&gt; optionalAddress = getUserById(userId)</span><br><span class="line">                .map(OptionalExample::getAddressByUser);</span><br><span class="line"></span><br><span class="line">        String cityWithoutFlatMap;</span><br><span class="line">        <span class="keyword">if</span> (optionalAddress.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Address&gt; addressOptional = optionalAddress.get();</span><br><span class="line">            <span class="keyword">if</span> (addressOptional.isPresent()) &#123;</span><br><span class="line">                Address address = addressOptional.get();</span><br><span class="line">                cityWithoutFlatMap = address.getCity();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city without flatMap: &quot;</span> + cityWithoutFlatMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Stream</code>和<code>Optional</code>中正确使用<code>flatMap</code>可以减少很多不必要的代码。</p>
<h3 id="判断-value-是否为-null"><a href="#判断-value-是否为-null" class="headerlink" title="判断 value 是否为 null"></a>判断 value 是否为 null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value是否为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value不为null执行consumer.accept</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">    consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-value"><a href="#获取-value" class="headerlink" title="获取 value"></a>获取 value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">* the result of that invocation.</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回other的执行结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回T</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则抛出参数返回的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value为null抛出NoSuchElementException，不为空返回value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是empty返回empty</span></span><br><span class="line"><span class="comment">* 2. predicate.test(value)==true 返回this，否则返回empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of()</code>、 <code>get()</code>、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).filter(v-&gt;v==<span class="number">1</span>).orElse(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p>
<ol>
<li>非线程安全</li>
<li>时区处理麻烦</li>
<li>各种格式化、和时间计算繁琐</li>
<li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li>
</ol>
<p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p>
<h3 id="java-time-主要类"><a href="#java-time-主要类" class="headerlink" title="java.time 主要类"></a>java.time 主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而 <code>java.time</code> 把它们进行了分离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.class <span class="comment">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span></span><br><span class="line">LocalDate.class <span class="comment">//日期 format: yyyy-MM-dd</span></span><br><span class="line">LocalTime.class <span class="comment">//时间 format: HH:mm:ss</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oldFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date now = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    String date  = sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    SimpleDateFormat sdft = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    String time = sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    SimpleDateFormat sdfdt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String datetime = sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    LocalDate date = LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    LocalTime time = LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String dateTimeStr = dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已弃用</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">Date date1 = sdf.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>);</span><br><span class="line">LocalDate.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2021-01-26 12:12:22&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalTime.parse(<span class="string">&quot;12:12:22&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的 <code>of</code> 或 <code>parse</code> 方法。</p>
<h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1/2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p>
<p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     SimpleDateFormat formatDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     Calendar ca = Calendar.getInstance();</span><br><span class="line">     ca.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">     Date d = ca.getTime();</span><br><span class="line">     String after = formatDate.format(d);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span></span><br><span class="line">     String dates1 = <span class="string">&quot;2021-12-23&quot;</span>;</span><br><span class="line">   String dates2 = <span class="string">&quot;2021-02-26&quot;</span>;</span><br><span class="line">     SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     Date date1 = format.parse(dates1);</span><br><span class="line">     Date date2 = format.parse(dates2);</span><br><span class="line">     <span class="keyword">int</span> day = (<span class="keyword">int</span>) ((date1.getTime() - date2.getTime()) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>));</span><br><span class="line">     System.out.println(dates1 + <span class="string">&quot;和&quot;</span> + dates2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushWeek</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     LocalDate localDate = LocalDate.now();</span><br><span class="line">     <span class="comment">//方法1</span></span><br><span class="line">     LocalDate after = localDate.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">     <span class="comment">//方法2</span></span><br><span class="line">     LocalDate after2 = localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月</span></span><br><span class="line">     LocalDate date1 = LocalDate.parse(<span class="string">&quot;2021-02-26&quot;</span>);</span><br><span class="line">     LocalDate date2 = LocalDate.parse(<span class="string">&quot;2021-12-23&quot;</span>);</span><br><span class="line">     Period period = Period.between(date1, date2);</span><br><span class="line">     System.out.println(<span class="string">&quot;date1 到 date2 相隔：&quot;</span></span><br><span class="line">                + period.getYears() + <span class="string">&quot;年&quot;</span></span><br><span class="line">                + period.getMonths() + <span class="string">&quot;月&quot;</span></span><br><span class="line">                + period.getDays() + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">   <span class="comment">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span></span><br><span class="line">     <span class="comment">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span></span><br><span class="line">     <span class="comment">//如果要获取纯粹的总天数应该用下面的方法</span></span><br><span class="line">     <span class="keyword">long</span> day = date2.toEpochDay() - date1.toEpochDay();</span><br><span class="line">     System.out.println(date1 + <span class="string">&quot;和&quot;</span> + date2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//打印结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h3><p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>
<p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前月第一天：</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        String first = format.format(c.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;first day:&quot;</span> + first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前月最后一天</span></span><br><span class="line">        Calendar ca = Calendar.getInstance();</span><br><span class="line">        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        String last = format.format(ca.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年最后一天</span></span><br><span class="line">        Calendar currCal = Calendar.getInstance();</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.clear();</span><br><span class="line">        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));</span><br><span class="line">        calendar.roll(Calendar.DAY_OF_YEAR, -<span class="number">1</span>);</span><br><span class="line">        Date time = calendar.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDayNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    LocalDate nextDay = lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    LocalDate lastMondayOf2021 = LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p>
<h3 id="JDBC-和-java8"><a href="#JDBC-和-java8" class="headerlink" title="JDBC 和 java8"></a>JDBC 和 java8</h3><p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p>
<ol>
<li><code>Date</code> —&gt; <code>LocalDate</code></li>
<li><code>Time</code> —&gt; <code>LocalTime</code></li>
<li><code>Timestamp</code> —&gt; <code>LocalDateTime</code></li>
</ol>
<p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><blockquote>
<p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p>
</blockquote>
<p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//北京时间：Wed Jan 27 14:05:29 CST 2021</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat bjSdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//北京时区</span></span><br><span class="line">bjSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 北京时间:&quot;</span> + bjSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时区</span></span><br><span class="line">SimpleDateFormat tokyoSdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">tokyoSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Tokyo&quot;</span>));  <span class="comment">// 设置东京时区</span></span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 东京时间:&quot;</span> + tokyoSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果直接print会自动转成当前时区的时间</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//Wed Jan 27 14:05:29 CST 2021</span></span><br></pre></td></tr></table></figure>

<p>在新特性中引入了 <code>java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时区时间</span></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时区时间: &quot;</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时间</span></span><br><span class="line">ZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(<span class="string">&quot;JST&quot;</span>));</span><br><span class="line">ZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId);</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间: &quot;</span> + tokyoTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZonedDateTime 转 LocalDateTime</span></span><br><span class="line">LocalDateTime localDateTime = tokyoTime.toLocalDateTime();</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间转当地时间: &quot;</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime 转 ZonedDateTime</span></span><br><span class="line">ZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(<span class="string">&quot;本地时区时间: &quot;</span> + localZoned);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">当前时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T14:<span class="number">43</span>:<span class="number">58.735</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line">东京时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span>+09:<span class="number">00</span>[Asia/Tokyo]</span><br><span class="line">东京时间转当地时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span></span><br><span class="line">当地时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">53</span>:<span class="number">35.618</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们梳理总结的 java 8 新特性有</p>
<ul>
<li>Interface &amp; functional Interface</li>
<li>Lambda</li>
<li>Stream</li>
<li>Optional</li>
<li>Date time-api</li>
</ul>
<p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>谢谢你请我喝牛奶</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/img/wechat.png" alt="hunkier 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/img/alipay.png" alt="hunkier 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/hunkied">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/hunkier">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/assets/img/my_wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/jdk/" rel="tag"><i class="fa fa-tag"></i> jdk</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Deploying-Spring-Boot-Applications/" rel="prev" title="部署Spring Boot应用">
      <i class="fa fa-chevron-left"></i> 部署Spring Boot应用
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java21-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">Java21 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-430%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">JEP 430：字符串模板（预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP431%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">JEP431：序列化集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-439%EF%BC%9A%E5%88%86%E4%BB%A3-ZGC"><span class="nav-number">1.3.</span> <span class="nav-text">JEP 439：分代 ZGC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-440%EF%BC%9A%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">JEP 440：记录模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-441%EF%BC%9Aswitch-%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.5.</span> <span class="nav-text">JEP 441：switch 的模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-442-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">JEP 442: 外部函数和内存 API（第三次预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-443%EF%BC%9A%E6%9C%AA%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">JEP 443：未命名模式和变量（预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-444%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.8.</span> <span class="nav-text">JEP 444：虚拟线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-445%EF%BC%9A%E6%9C%AA%E5%91%BD%E5%90%8D%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B-main-%E6%96%B9%E6%B3%95-%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">JEP 445：未命名类和实例 main 方法 （预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.10.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java20-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">Java20 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-429%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%80%BC%EF%BC%88%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">JEP 429：作用域值（第一次孵化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-432%EF%BC%9A%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">JEP 432：记录模式（第二次预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-433%EF%BC%9Aswitch-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">JEP 433：switch 模式匹配（第四次预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-434-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">JEP 434: 外部函数和内存 API（第二次预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-436-%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">JEP 436: 虚拟线程（第二次预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-437-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">JEP 437: 结构化并发(第二次孵化)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-432%EF%BC%9A%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">JEP 432：向量 API（第五次孵化）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java19-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">Java19 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-424-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">JEP 424: 外部函数和内存 API（预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-425-%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">JEP 425: 虚拟线程（预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-426-%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">JEP 426: 向量 API（第四次孵化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-428-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-%E5%AD%B5%E5%8C%96"><span class="nav-number">3.4.</span> <span class="nav-text">JEP 428: 结构化并发(孵化)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java18-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">Java18 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-400-%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%BA-UTF-8"><span class="nav-number">4.1.</span> <span class="nav-text">JEP 400:默认字符集为 UTF-8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-408-%E7%AE%80%E6%98%93%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">JEP 408:简易的 Web 服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-413-%E4%BC%98%E5%8C%96-Java-API-%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="nav-number">4.3.</span> <span class="nav-text">JEP 413:优化 Java API 文档中的代码片段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-416-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E6%A0%B8%E5%BF%83"><span class="nav-number">4.4.</span> <span class="nav-text">JEP 416:使用方法句柄重新实现反射核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-417-%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">JEP 417: 向量 API（第三次孵化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-418-%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90-SPI"><span class="nav-number">4.6.</span> <span class="nav-text">JEP 418:互联网地址解析 SPI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-419-Foreign-Function-amp-Memory-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">4.7.</span> <span class="nav-text">JEP 419:Foreign Function &amp; Memory API（第二次孵化）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">Java17 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-356-%E5%A2%9E%E5%BC%BA%E7%9A%84%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">JEP 356:增强的伪随机数生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-398-%E5%BC%83%E7%94%A8-Applet-API-%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="nav-number">5.2.</span> <span class="nav-text">JEP 398:弃用 Applet API 以进行删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-406-switch-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%EF%BC%88%E9%A2%84%E8%A7%88%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">JEP 406:switch 的类型匹配（预览）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-407-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="nav-number">5.4.</span> <span class="nav-text">JEP 407:删除远程方法调用激活机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-409-%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88%E8%BD%AC%E6%AD%A3%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">JEP 409:密封类（转正）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-410-%E5%88%A0%E9%99%A4%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%9A%84-AOT-%E5%92%8C-JIT-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">5.6.</span> <span class="nav-text">JEP 410:删除实验性的 AOT 和 JIT 编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-411-%E5%BC%83%E7%94%A8%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="nav-number">5.7.</span> <span class="nav-text">JEP 411:弃用安全管理器以进行删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-412-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98-API%EF%BC%88%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">5.8.</span> <span class="nav-text">JEP 412:外部函数和内存 API（孵化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-414-%E5%90%91%E9%87%8F-API%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96%EF%BC%89"><span class="nav-number">5.9.</span> <span class="nav-text">JEP 414:向量 API（第二次孵化）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java16-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">Java16 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-338-%E5%90%91%E9%87%8F-API-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AD%B5%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">JEP 338:向量 API(第一次孵化)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-347-%E5%90%AF%E7%94%A8-C-14-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-number">6.2.</span> <span class="nav-text">JEP 347:启用 C++ 14 语言特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-376-ZGC-%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E5%A4%84%E7%90%86"><span class="nav-number">6.3.</span> <span class="nav-text">JEP 376:ZGC 并发线程堆栈处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-387-%E5%BC%B9%E6%80%A7%E5%85%83%E7%A9%BA%E9%97%B4"><span class="nav-number">6.4.</span> <span class="nav-text">JEP 387:弹性元空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-390-%E5%AF%B9%E5%9F%BA%E4%BA%8E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%8F%91%E5%87%BA%E8%AD%A6%E5%91%8A"><span class="nav-number">6.5.</span> <span class="nav-text">JEP 390:对基于值的类发出警告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-392-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="nav-number">6.6.</span> <span class="nav-text">JEP 392:打包工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-393-%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-API-%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AD%B5%E5%8C%96"><span class="nav-number">6.7.</span> <span class="nav-text">JEP 393:外部内存访问 API(第三次孵化)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-394-instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E8%BD%AC%E6%AD%A3"><span class="nav-number">6.8.</span> <span class="nav-text">JEP 394:instanceof 模式匹配(转正)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-395-%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B-%E8%BD%AC%E6%AD%A3"><span class="nav-number">6.9.</span> <span class="nav-text">JEP 395:记录类型(转正)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-396-%E9%BB%98%E8%AE%A4%E5%BC%BA%E5%B0%81%E8%A3%85-JDK-%E5%86%85%E9%83%A8%E5%85%83%E7%B4%A0"><span class="nav-number">6.10.</span> <span class="nav-text">JEP 396:默认强封装 JDK 内部元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP-397-%E5%AF%86%E5%B0%81%E7%B1%BB-%E9%A2%84%E8%A7%88"><span class="nav-number">6.11.</span> <span class="nav-text">JEP 397:密封类(预览)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E4%B8%8E%E6%94%B9%E8%BF%9B"><span class="nav-number">6.12.</span> <span class="nav-text">其他优化与改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">6.13.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java14-15-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">7.</span> <span class="nav-text">Java14~15 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java14"><span class="nav-number">7.1.</span> <span class="nav-text">Java14</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E7%B2%BE%E5%87%86%E6%8F%90%E7%A4%BA"><span class="nav-number">7.1.1.</span> <span class="nav-text">空指针异常精准提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-%E7%9A%84%E5%A2%9E%E5%BC%BA-%E8%BD%AC%E6%AD%A3"><span class="nav-number">7.1.2.</span> <span class="nav-text">switch 的增强(转正)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E8%A7%88%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">7.1.3.</span> <span class="nav-text">预览新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#record-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">7.1.3.1.</span> <span class="nav-text">record 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-number">7.1.3.2.</span> <span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof-%E5%A2%9E%E5%BC%BA"><span class="nav-number">7.1.3.3.</span> <span class="nav-text">instanceof 增强</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">7.1.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java15"><span class="nav-number">7.2.</span> <span class="nav-text">Java15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CharSequence"><span class="nav-number">7.2.1.</span> <span class="nav-text">CharSequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">7.2.2.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZGC-%E8%BD%AC%E6%AD%A3"><span class="nav-number">7.2.3.</span> <span class="nav-text">ZGC(转正)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EdDSA-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.4.</span> <span class="nav-text">EdDSA(数字签名算法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97-%E8%BD%AC%E6%AD%A3"><span class="nav-number">7.2.5.</span> <span class="nav-text">文本块(转正)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%B1%BB-Hidden-Classes"><span class="nav-number">7.2.6.</span> <span class="nav-text">隐藏类(Hidden Classes)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E8%A7%88%E6%96%B0%E7%89%B9%E6%80%A7-1"><span class="nav-number">7.2.7.</span> <span class="nav-text">预览新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="nav-number">7.2.7.1.</span> <span class="nav-text">密封类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">7.2.7.2.</span> <span class="nav-text">instanceof 模式匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">7.2.8.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java12-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">Java12 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E5%A2%9E%E5%BC%BA"><span class="nav-number">8.0.1.</span> <span class="nav-text">String 增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Files-%E5%A2%9E%E5%BC%BA%EF%BC%88%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83%EF%BC%89"><span class="nav-number">8.0.2.</span> <span class="nav-text">Files 增强（文件比较）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">8.0.3.</span> <span class="nav-text">数字格式化工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shenandoah-GC"><span class="nav-number">8.0.4.</span> <span class="nav-text">Shenandoah GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8%E4%BC%98%E5%8C%96"><span class="nav-number">8.0.5.</span> <span class="nav-text">G1 收集器优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E8%A7%88%E6%96%B0%E7%89%B9%E6%80%A7-2"><span class="nav-number">8.0.6.</span> <span class="nav-text">预览新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA-Switch"><span class="nav-number">8.0.6.1.</span> <span class="nav-text">增强 Switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-1"><span class="nav-number">8.0.6.2.</span> <span class="nav-text">instanceof 模式匹配</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java13-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text">Java13 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA-ZGC-%E9%87%8A%E6%94%BE%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-number">9.0.1.</span> <span class="nav-text">增强 ZGC(释放未使用内存)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketAPI-%E9%87%8D%E6%9E%84"><span class="nav-number">9.0.2.</span> <span class="nav-text">SocketAPI 重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileSystems"><span class="nav-number">9.0.3.</span> <span class="nav-text">FileSystems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81-CDS-%E5%AD%98%E6%A1%A3"><span class="nav-number">9.0.4.</span> <span class="nav-text">动态 CDS 存档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E8%A7%88%E6%96%B0%E7%89%B9%E6%80%A7-3"><span class="nav-number">9.0.5.</span> <span class="nav-text">预览新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97-1"><span class="nav-number">9.0.5.1.</span> <span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BA-Switch-%E5%BC%95%E5%85%A5-yield-%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%B0-Switch-%E4%B8%AD"><span class="nav-number">9.0.5.2.</span> <span class="nav-text">增强 Switch(引入 yield 关键字到 Switch 中)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">9.1.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E9%A2%84%E8%A7%88%E7%89%B9%E6%80%A7"><span class="nav-number">9.1.1.</span> <span class="nav-text">关于预览特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BC%98%E5%8C%96"><span class="nav-number">9.1.2.</span> <span class="nav-text">JVM 虚拟机优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-number">9.2.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">Java11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-Client-%E6%A0%87%E5%87%86%E5%8C%96"><span class="nav-number">10.1.</span> <span class="nav-text">HTTP Client 标准化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E5%A2%9E%E5%BC%BA-1"><span class="nav-number">10.2.</span> <span class="nav-text">String 增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-%E5%A2%9E%E5%BC%BA"><span class="nav-number">10.3.</span> <span class="nav-text">Optional 增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZGC-%E5%8F%AF%E4%BC%B8%E7%BC%A9%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">10.4.</span> <span class="nav-text">ZGC(可伸缩低延迟垃圾收集器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-%E5%8F%82%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">10.5.</span> <span class="nav-text">Lambda 参数的局部变量语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%8D%95%E6%96%87%E4%BB%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.6.</span> <span class="nav-text">启动单文件源代码程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">10.7.</span> <span class="nav-text">其他新特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">11.</span> <span class="nav-text">Java10 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-var"><span class="nav-number">11.1.</span> <span class="nav-text">局部变量类型推断(var)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.2.</span> <span class="nav-text">垃圾回收器接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%B9%B6%E8%A1%8C-Full-GC"><span class="nav-number">11.3.</span> <span class="nav-text">G1 并行 Full GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%A2%9E%E5%BC%BA"><span class="nav-number">11.4.</span> <span class="nav-text">集合增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-%E5%A2%9E%E5%BC%BA-1"><span class="nav-number">11.5.</span> <span class="nav-text">Optional 增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB-%E6%89%A9%E5%B1%95-CDS-%E5%8A%9F%E8%83%BD"><span class="nav-number">11.6.</span> <span class="nav-text">应用程序类数据共享(扩展 CDS 功能)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%9A%84%E5%9F%BA%E4%BA%8E-Java-%E7%9A%84-JIT-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">11.7.</span> <span class="nav-text">实验性的基于 Java 的 JIT 编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-2"><span class="nav-number">11.8.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">12.</span> <span class="nav-text">Java9 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JShell"><span class="nav-number">12.1.</span> <span class="nav-text">JShell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="nav-number">12.2.</span> <span class="nav-text">模块化系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E6%88%90%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">12.3.</span> <span class="nav-text">G1 成为默认垃圾回收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="nav-number">12.4.</span> <span class="nav-text">快速创建不可变集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="nav-number">12.5.</span> <span class="nav-text">String 存储结构优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">12.6.</span> <span class="nav-text">接口私有方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-with-resources-%E5%A2%9E%E5%BC%BA"><span class="nav-number">12.7.</span> <span class="nav-text">try-with-resources 增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-amp-Optional-%E5%A2%9E%E5%BC%BA"><span class="nav-number">12.8.</span> <span class="nav-text">Stream &amp; Optional 增强</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-API"><span class="nav-number">12.9.</span> <span class="nav-text">进程 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81-%EF%BC%88-Reactive-Streams-%EF%BC%89"><span class="nav-number">12.10.</span> <span class="nav-text">响应式流 （ Reactive Streams ）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%8F%A5%E6%9F%84"><span class="nav-number">12.11.</span> <span class="nav-text">变量句柄</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">12.12.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.</span> <span class="nav-text">Java8 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Interface"><span class="nav-number">13.1.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functional-interface-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.2.</span> <span class="nav-text">functional interface 函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.3.</span> <span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">13.3.1.</span> <span class="nav-text">语法格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-%E5%AE%9E%E6%88%98"><span class="nav-number">13.3.2.</span> <span class="nav-text">Lambda 实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">13.3.2.1.</span> <span class="nav-text">替代匿名内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3"><span class="nav-number">13.3.2.2.</span> <span class="nav-text">集合迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">13.3.2.3.</span> <span class="nav-text">方法的引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="nav-number">13.3.2.4.</span> <span class="nav-text">访问变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">13.4.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.4.1.</span> <span class="nav-text">流类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number">13.4.3.</span> <span class="nav-text">实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="nav-number">13.4.4.</span> <span class="nav-text">延迟执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">13.4.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional"><span class="nav-number">13.5.</span> <span class="nav-text">Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Optional"><span class="nav-number">13.5.1.</span> <span class="nav-text">如何创建一个 Optional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD-value-%E6%98%AF%E5%90%A6%E4%B8%BA-null"><span class="nav-number">13.5.2.</span> <span class="nav-text">判断 value 是否为 null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-value"><span class="nav-number">13.5.3.</span> <span class="nav-text">获取 value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%80%BC"><span class="nav-number">13.5.4.</span> <span class="nav-text">过滤值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">13.5.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date-Time-API"><span class="nav-number">13.6.</span> <span class="nav-text">Date-Time API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-time-%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="nav-number">13.6.1.</span> <span class="nav-text">java.time 主要类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">13.6.2.</span> <span class="nav-text">格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F"><span class="nav-number">13.6.3.</span> <span class="nav-text">字符串转日期格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97"><span class="nav-number">13.6.4.</span> <span class="nav-text">日期计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F"><span class="nav-number">13.6.5.</span> <span class="nav-text">获取指定日期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC-%E5%92%8C-java8"><span class="nav-number">13.6.6.</span> <span class="nav-text">JDBC 和 java8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%8C%BA"><span class="nav-number">13.6.7.</span> <span class="nav-text">时区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">13.6.8.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">13.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hunkier"
      src="/assets/img/avatar.jpg">
  <p class="site-author-name" itemprop="name">hunkier</p>
  <div class="site-description" itemprop="description">学习笔记，开源代码，技术分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hunkier" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hunkier" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huangkuier@gmail.com" title="E-Mail → mailto:huangkuier@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/hunkied" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;hunkied" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/huang.hunkier" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;huang.hunkier" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">赣ICP备20001211号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hunkier</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://hunkier.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://hunkier.cn/Java-New-Features/";
    this.page.identifier = "Java-New-Features/";
    this.page.title = "Java 新特性";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://hunkier.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
