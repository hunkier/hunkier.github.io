<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hunkier</title>
  
  <subtitle>学习笔记，开源代码，技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hunkier.cn/"/>
  <updated>2020-08-18T02:21:07.011Z</updated>
  <id>https://hunkier.cn/</id>
  
  <author>
    <name>hunkier</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发-- Lock 接口</title>
    <link href="https://hunkier.cn/Java-Concurrent-Lock-Interface/"/>
    <id>https://hunkier.cn/Java-Concurrent-Lock-Interface/</id>
    <published>2020-02-22T06:55:00.000Z</published>
    <updated>2020-08-18T02:21:07.011Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;​        锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁是可以允许多个线程并发的访问共享资源，比如读写锁）。在 Lock 接口出现之前，Java 程序是靠 synchronized 关键字实现锁的功能的，而 JavaSE 5 之后，并发包中新增了 Lock 接口（以及相关类），只是在使用时需要显式地获取和释放锁。虽然它缺少了 （通过 synchronized 块或者方法所提供的）隐式获取和释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="lock" scheme="https://hunkier.cn/tags/lock/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--原子操作的实现原理</title>
    <link href="https://hunkier.cn/Java-Concurrent-realization-principle-of-atomic-operation/"/>
    <id>https://hunkier.cn/Java-Concurrent-realization-principle-of-atomic-operation/</id>
    <published>2020-02-06T02:38:29.000Z</published>
    <updated>2020-07-13T02:57:22.275Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。在多处理器上实现原子操作就变得有点复杂。让我们一起来聊一聊在Intel处理器和Java里是如何实现原子操作的。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
      <category term="atomic" scheme="https://hunkier.cn/tags/atomic/"/>
    
      <category term="CAS" scheme="https://hunkier.cn/tags/CAS/"/>
    
      <category term="LOCK" scheme="https://hunkier.cn/tags/LOCK/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--锁的升级与对比</title>
    <link href="https://hunkier.cn/Java-Concurrent-lock-escalation-comparison/"/>
    <id>https://hunkier.cn/Java-Concurrent-lock-escalation-comparison/</id>
    <published>2020-02-05T03:15:10.000Z</published>
    <updated>2020-07-12T00:24:26.568Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
      <category term="lock escalation" scheme="https://hunkier.cn/tags/lock-escalation/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发--Java对象头</title>
    <link href="https://hunkier.cn/Java-Concurrent-java-object-header/"/>
    <id>https://hunkier.cn/Java-Concurrent-java-object-header/</id>
    <published>2020-02-04T07:31:11.000Z</published>
    <updated>2020-07-11T14:44:32.209Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，如表所示。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
      <category term="object header" scheme="https://hunkier.cn/tags/object-header/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发--synchronized 的实现原理与应用</title>
    <link href="https://hunkier.cn/Java-Concurrent-synchronized/"/>
    <id>https://hunkier.cn/Java-Concurrent-synchronized/</id>
    <published>2020-02-03T08:51:06.000Z</published>
    <updated>2020-07-10T01:08:54.289Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了。本文详细介绍 Java SE 1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
      <category term="Synchronized" scheme="https://hunkier.cn/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--volatile 的应用</title>
    <link href="https://hunkier.cn/Java-Concurrent-volatile/"/>
    <id>https://hunkier.cn/Java-Concurrent-volatile/</id>
    <published>2020-02-02T06:55:00.000Z</published>
    <updated>2020-07-11T23:21:22.841Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-volatile的应用&quot;&gt;&lt;a href=&quot;#1-volatile的应用&quot; class=&quot;headerlink&quot; title=&quot;1　volatile的应用&quot;&gt;&lt;/a&gt;1　volatile的应用&lt;/h2&gt;&lt;p&gt;在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。本文将深入分析在硬件层面上Intel处理器是如何实现volatile的，通过深入分析帮助我们正确地使用volatile变量。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/categories/java/concurrent/"/>
    
    
      <category term="jvm" scheme="https://hunkier.cn/tags/jvm/"/>
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="concurrent" scheme="https://hunkier.cn/tags/concurrent/"/>
    
      <category term="volatile" scheme="https://hunkier.cn/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装 google chrome</title>
    <link href="https://hunkier.cn/CentOS-7-install-google-chrome/"/>
    <id>https://hunkier.cn/CentOS-7-install-google-chrome/</id>
    <published>2020-01-20T13:18:50.000Z</published>
    <updated>2020-03-26T08:37:56.750Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;第一步： 执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd /etc/yum.repos.d/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="centos" scheme="https://hunkier.cn/categories/centos/"/>
    
      <category term="chrome" scheme="https://hunkier.cn/categories/centos/chrome/"/>
    
    
      <category term="centos" scheme="https://hunkier.cn/tags/centos/"/>
    
      <category term="chrome" scheme="https://hunkier.cn/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="https://hunkier.cn/Design-patter-7-principle/"/>
    <id>https://hunkier.cn/Design-patter-7-principle/</id>
    <published>2020-01-10T13:34:00.000Z</published>
    <updated>2020-02-28T09:17:08.273Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、设计模式的目的&quot;&gt;&lt;a href=&quot;#一、设计模式的目的&quot; class=&quot;headerlink&quot; title=&quot;一、设计模式的目的&quot;&gt;&lt;/a&gt;一、设计模式的目的&lt;/h1&gt;&lt;p&gt;​    编写软件过程中，程序员面临着来自耦合性、内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://hunkier.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="七大原则" scheme="https://hunkier.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计模式" scheme="https://hunkier.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="七大原则" scheme="https://hunkier.cn/tags/%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>使用 https 协议部署博客</title>
    <link href="https://hunkier.cn/deploy-blog-with-https/"/>
    <id>https://hunkier.cn/deploy-blog-with-https/</id>
    <published>2019-12-15T08:48:34.000Z</published>
    <updated>2020-05-22T14:16:17.549Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;https 成为互联网标配，自然得跟上，给自己的博客用加密版的传输协议 https。&lt;/p&gt;
&lt;p&gt;首先需要一个域名和一台拥有固定外网 ip 的服务器，使域名可以解析到该服务器上。&lt;a href=&quot;https://caddyserver.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;caddy&lt;/a&gt; 可以自动能够向 Let’s Encrypt 申请和续期免费证书，有效期为 3 个月， 到期后自动续期。&lt;/p&gt;
    
    </summary>
    
      <category term="https" scheme="https://hunkier.cn/categories/https/"/>
    
      <category term="blog" scheme="https://hunkier.cn/categories/https/blog/"/>
    
      <category term="caddy" scheme="https://hunkier.cn/categories/https/blog/caddy/"/>
    
    
      <category term="blog" scheme="https://hunkier.cn/tags/blog/"/>
    
      <category term="https" scheme="https://hunkier.cn/tags/https/"/>
    
      <category term="caddy" scheme="https://hunkier.cn/tags/caddy/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 修改时区、设置时间</title>
    <link href="https://hunkier.cn/CentOS-chanage-date-zone/"/>
    <id>https://hunkier.cn/CentOS-chanage-date-zone/</id>
    <published>2019-12-14T02:09:01.000Z</published>
    <updated>2019-12-16T12:41:27.001Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;一、修改时区：&lt;/p&gt;
&lt;p&gt;  方法1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cp  /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="centos" scheme="https://hunkier.cn/categories/centos/"/>
    
      <category term="date" scheme="https://hunkier.cn/categories/centos/date/"/>
    
      <category term="timezone" scheme="https://hunkier.cn/categories/centos/date/timezone/"/>
    
    
      <category term="centos" scheme="https://hunkier.cn/tags/centos/"/>
    
      <category term="date" scheme="https://hunkier.cn/tags/date/"/>
    
      <category term="timezone" scheme="https://hunkier.cn/tags/timezone/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 安装 cockpit 管理系统</title>
    <link href="https://hunkier.cn/CentOS-install-mamager-cockpit/"/>
    <id>https://hunkier.cn/CentOS-install-mamager-cockpit/</id>
    <published>2019-12-13T11:51:03.000Z</published>
    <updated>2020-01-14T02:15:00.476Z</updated>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://cockpit-project.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cockpit&lt;/a&gt; 是一个基于 Web 界面的应用，它提供了对系统的图形化管理。&lt;/p&gt;
&lt;p&gt;拥有如下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控系统活动（CPU、内存、磁盘 IO 和网络流量） —— 系统&lt;/li&gt;
&lt;li&gt;查看系统日志条目 —— 日志&lt;/li&gt;
&lt;li&gt;查看磁盘分区的容量 —— 存储&lt;/li&gt;
&lt;li&gt;查看网络活动（发送和接收） —— 网络
    
    </summary>
    
      <category term="Linux" scheme="https://hunkier.cn/categories/Linux/"/>
    
      <category term="cockpit" scheme="https://hunkier.cn/categories/Linux/cockpit/"/>
    
    
      <category term="Linux" scheme="https://hunkier.cn/tags/Linux/"/>
    
      <category term="cockpit" scheme="https://hunkier.cn/tags/cockpit/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="https://hunkier.cn/algorithm-radix-sort/"/>
    <id>https://hunkier.cn/algorithm-radix-sort/</id>
    <published>2019-12-04T00:26:30.000Z</published>
    <updated>2019-12-04T00:44:22.464Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;将所有待比较数值 （正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="radix sort" scheme="https://hunkier.cn/categories/java/algorithm/radix-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="radix sort" scheme="https://hunkier.cn/tags/radix-sort/"/>
    
  </entry>
  
  <entry>
    <title>桶排序</title>
    <link href="https://hunkier.cn/algorithm-bucket-sort/"/>
    <id>https://hunkier.cn/algorithm-bucket-sort/</id>
    <published>2019-12-03T00:10:03.000Z</published>
    <updated>2019-12-03T00:11:55.466Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;桶排序的基本思想是：把数组 arr 划分为 n 个大小相同子区间 (桶), 每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里面只有一个元素的情况。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="bucket sort" scheme="https://hunkier.cn/categories/java/algorithm/bucket-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="bucket sort" scheme="https://hunkier.cn/tags/bucket-sort/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 下使用 Percona XtraBackup 备份和恢复 MySQL5.7</title>
    <link href="https://hunkier.cn/Percona-XtraBackup-MySQL5-7/"/>
    <id>https://hunkier.cn/Percona-XtraBackup-MySQL5-7/</id>
    <published>2019-11-29T01:14:01.000Z</published>
    <updated>2020-08-19T08:50:20.325Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.percona.com/software/mysql-database/percona-xtrabackup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XtraBackup&lt;/a&gt; 是 &lt;a href=&quot;https://www.percona.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Percona&lt;/a&gt; 开源的免费数据库热备份软件，它能对InnoDB数据库和XtraDB存储引擎的数据库非阻塞地备份（对于MyISAM的备份同样需要加表锁）；mysqldump备份方式是采用的逻辑备份，其最大的缺陷是备份和恢复速度较慢，如果数据库大于50G，mysqldump备份就不太适合。&lt;/p&gt;
    
    </summary>
    
      <category term="centos" scheme="https://hunkier.cn/categories/centos/"/>
    
      <category term="mysql" scheme="https://hunkier.cn/categories/centos/mysql/"/>
    
      <category term="Percona XtraBackup" scheme="https://hunkier.cn/categories/centos/mysql/Percona-XtraBackup/"/>
    
    
      <category term="centos" scheme="https://hunkier.cn/tags/centos/"/>
    
      <category term="mysql" scheme="https://hunkier.cn/tags/mysql/"/>
    
      <category term="Percona XtraBackup" scheme="https://hunkier.cn/tags/Percona-XtraBackup/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://hunkier.cn/algorithm-merge-sort/"/>
    <id>https://hunkier.cn/algorithm-merge-sort/</id>
    <published>2019-11-28T00:50:08.000Z</published>
    <updated>2019-11-28T01:16:12.515Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;归并 （Merge） 排序法是将两个 （或两个以上）有序表合并成一个新的有序表，即把待排序序列分为多干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="merge sort" scheme="https://hunkier.cn/categories/java/algorithm/merge-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="merge sort" scheme="https://hunkier.cn/tags/merge-sort/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://hunkier.cn/algorithm-shell-sort/"/>
    <id>https://hunkier.cn/algorithm-shell-sort/</id>
    <published>2019-11-27T00:23:42.000Z</published>
    <updated>2020-06-07T00:57:29.519Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;基本思想：先将整个待排序的记录分割成若干子序列分别进行插入排序，待整个序列中的记录 ”基本有序“ 时，再对全体记录进行依次直接插入排序。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="shell sort" scheme="https://hunkier.cn/categories/java/algorithm/shell-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="shell sort" scheme="https://hunkier.cn/tags/shell-sort/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://hunkier.cn/algorithm-quick-sort/"/>
    <id>https://hunkier.cn/algorithm-quick-sort/</id>
    <published>2019-11-26T00:21:07.000Z</published>
    <updated>2019-11-27T00:24:40.829Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序的原理：选择一个关键值作为基准值。比较基准值小的都放在左边序列(一般是无序的), 比基准值大的都在右边(一般是无序的)。一般选择序列的第一个元素。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="quick sort" scheme="https://hunkier.cn/categories/java/algorithm/quick-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="quick sort" scheme="https://hunkier.cn/tags/quick-sort/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="https://hunkier.cn/algorithm-insert-sort/"/>
    <id>https://hunkier.cn/algorithm-insert-sort/</id>
    <published>2019-11-23T02:43:53.000Z</published>
    <updated>2019-11-23T02:46:27.565Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克。在开始摸牌时，左手是空的，牌面朝下放在桌面。接着，一次从桌上磨起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从左到右地进行比较。无论什么时候，左手中的牌都是排好序的。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="insert sort" scheme="https://hunkier.cn/categories/java/algorithm/insert-sort/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="insert sort" scheme="https://hunkier.cn/tags/insert-sort/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="https://hunkier.cn/algorithm-bubble-sort/"/>
    <id>https://hunkier.cn/algorithm-bubble-sort/</id>
    <published>2019-11-22T00:20:15.832Z</published>
    <updated>2019-11-22T00:22:25.323Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;(1) 比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。&lt;/p&gt;
&lt;p&gt;(2) 这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就 ”沉“ 到数组di N-1 个位置。&lt;/p&gt;
&lt;p&gt;(3) N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="bubble sort" scheme="https://hunkier.cn/categories/java/algorithm/bubble-sort/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://hunkier.cn/algorithm-bi-search/"/>
    <id>https://hunkier.cn/algorithm-bi-search/</id>
    <published>2019-11-21T00:13:21.000Z</published>
    <updated>2019-11-21T00:16:30.281Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;又叫折半查找，要求待查找的序列有序。每次取中间位置与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止。否则序列中没有待查的关键字。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://hunkier.cn/categories/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/categories/java/algorithm/"/>
    
      <category term="biSearch" scheme="https://hunkier.cn/categories/java/algorithm/biSearch/"/>
    
    
      <category term="java" scheme="https://hunkier.cn/tags/java/"/>
    
      <category term="algorithm" scheme="https://hunkier.cn/tags/algorithm/"/>
    
      <category term="biSearch" scheme="https://hunkier.cn/tags/biSearch/"/>
    
  </entry>
  
</feed>
